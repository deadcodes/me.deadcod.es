{"searchDocs":[{"title":"DeadButterfly","type":0,"sectionRef":"#","url":"/docs/dead-butterfly","content":"DeadButterfly Dead Butterfly™ 2023.11 Features​ Features The tile your character was standing on when you started the script is considered as Home TileIf it detects that you're losing health, it runs back to the Home Tile.If you wander too far from the Home Tile, it goes back to the Home Tile. Configuration​ Configuration Set the name of the entity you want to catch on line 9 Changelog​ Changelog 2024-01-02 Release Release Code​ Code local API = require(&quot;api&quot;) local UTILS = require(&quot;utils&quot;) API.SetDrawLogs(true) API.SetDrawTrackedSkills(true) print(&quot;Dead's Butterfly Catcher started&quot;) API.logInfo(&quot;Dead's Butterfly Catcher started&quot;) local entityToCatch = &quot;Charming moth&quot; -- Set this value local startTime, afk = os.time(), os.time() local MAX_IDLE_TIME_MINUTES = 5 local failureCount = 0 local startTile = API.PlayerCoord() local health = API.GetHP_() local function idleCheck() local timeDiff = os.difftime(os.time(), afk) local randomTime = math.random((MAX_IDLE_TIME_MINUTES * 60) * 0.6, (MAX_IDLE_TIME_MINUTES * 60) * 0.9) if timeDiff &gt; randomTime then API.PIdle2() afk = os.time() return true end end local function gameStateChecks() local gameState = API.GetGameState() if (gameState ~= 3) then API.logError('Not ingame with state:' .. tostring(gameState)) API.Write_LoopyLoop(false) return end if API.InvFull_() then API.logError('inventory full, stopping') API.Write_LoopyLoop(false) return end if failureCount &gt; 50 then API.logError('Couldnt find moths more than 50 times, exiting') API.Write_LoopyLoop(false) end end local function walkBack() API.DoAction_WalkerW(startTile); end local function runBackIfUnderAttack() local currentHealth = API.GetHP_() if currentHealth &lt; health then API.logWarn('Were under attack, running back to start point') if not API.ReadPlayerMovin2() then walkBack() health = currentHealth end elseif currentHealth &gt; health then health = currentHealth end end local function CatchAButterfly() local interactingWithMoth = API.Local_PlayerInterActingWith_22(20, entityToCatch) if not (interactingWithMoth or API.ReadPlayerAnim() ~= 0) and not API.ReadPlayerMovin2() then local moth = API.FindNPCbyName(entityToCatch, 30) if moth ~= nil and moth.Id ~= 0 then if API.Math_DistanceF(moth.Tile_XYZ, API.PlayerCoordfloat()) &gt; 50 then API.logInfo('Too far from target, walking back') API.DoAction_WalkerF(moth.Tile_XYZ) end API.DoAction_NPC(0x29, API.OFF_ACT_InteractNPC_route, {moth.Id}, 50) else if API.Math_DistanceW(startTile, API.PlayerCoord()) &gt; 50 then API.logInfo('Wandered off, going back') walkBack() end failureCount = failureCount + 1 end failureCount = 0 UTILS.randomSleep(300) else runBackIfUnderAttack() end end API.logInfo('Starting to catch:' .. entityToCatch) API.Write_LoopyLoop(true) while API.Read_LoopyLoop() do gameStateChecks() idleCheck() runBackIfUnderAttack() API.DoRandomEvents() CatchAButterfly() UTILS.randomSleep(300) end ","keywords":"","version":"Next"},{"title":"Soft Clay Miner","type":0,"sectionRef":"#","url":"/docs/dead-prif-clay-miner","content":"Soft Clay Miner Soft Clay Miner™ 2024.02.01 Requirements​ Requirements Plague's End completed to access Prifddinas Features​ Features Automatically teleports to Prifddinas lodestone if too far away using lodestones.lua.Handles random events. + Keeps stamina above 100 while mining + Showcases use of DoAction_WalkerW for long distance walking. + Showcases an example implementation of how a state based script can work - Doesn't log back in if it gets logged out Configuration​ Configuration Set the keycode of the bank preset you want to use [bankPresetKeycode]. Follow this link to find keycodes Changelog​ Changelog 2024-02-01 Update 2.0 Now uses the updated UTIL functionsCode cleanup 2023-08-28 Release Release Code​ Code --[[ # Script Name: Dead's Prifddinas Soft Clay Miner # Description: &lt;Mines clay at Prifddinas.&gt; # Autor: &lt;Dead (dea.d - Discord)&gt; # Version: &lt;2.0&gt; # Datum: &lt;2024.02.01&gt; --]] print(&quot;Run Priff Clay Miner.&quot;) local version = &quot;2.0&quot; -- INCLUDES_START local API = require(&quot;api&quot;) local LODESTONES = require(&quot;lodestones&quot;) local UTILS = require(&quot;utils&quot;) -- INCLUDES_END API.SetDrawTrackedSkills(true) API.SetDrawLogs(true) -- VARIABLES_START local bankPresetKeyCode = 0x76 -- https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes local firstRun = true local runs = 0 local clayMined = 0 local scriptStartTime = os.time() local runStartTime = os.time() local lastRunTime = 0 local avgRunTime = 0 -- The X1,X2,Y1,Y2 coords of the rectangle that we consider to be the area in which clay is interactable. local clayArea = { 2137, 2156, 3334, 3354 } -- We update this value based on the state transitions local STATE = 0 -- All the states that we want to track local STATES = { GOTO_CLAY = 0, MINE_CLAY = 1, EMPTY_BAGS = 3, GOTO_PRIFF = 4 } -- Draws the black background local imguiBackground = API.CreateIG_answer(); imguiBackground.box_name = &quot;ImguiBackground&quot; imguiBackground.box_start = FFPOINT.new(20, 40, 0) imguiBackground.box_size = FFPOINT.new(220, 140, 0) imguiBackground.colour = ImColor.new(10, 13, 29) local ImGuiTitle = API.CreateIG_answer() ImGuiTitle.box_start = FFPOINT.new(25, 45, 0) ImGuiTitle.colour = ImColor.new(37, 194, 160) ImGuiTitle.string_value = &quot;Dead's Prif Clay Miner &quot; .. version -- imgui object for the number of tips local imguiRuns = API.CreateIG_answer(); imguiRuns.box_name = &quot;imguiRuns&quot;; imguiRuns.colour = ImColor.new(37, 194, 160) imguiRuns.box_start = FFPOINT.new(25, 75, 0); -- imgui object for the number of clay mined local imguiClayMined = API.CreateIG_answer(); imguiClayMined.box_name = &quot;imguiClayMined&quot;; imguiClayMined.colour = ImColor.new(37, 194, 160) imguiClayMined.box_start = FFPOINT.new(25, 90, 0); -- imgui object for runs per hour local imguiRunsPerHr = API.CreateIG_answer(); imguiRunsPerHr.box_name = &quot;imguiRunsPerHr&quot;; imguiRunsPerHr.colour = ImColor.new(37, 194, 160) imguiRunsPerHr.box_start = FFPOINT.new(25, 105, 0); -- imgui object for runtime local imguiLastRunTime = API.CreateIG_answer(); imguiLastRunTime.box_name = &quot;imguiLastRunTime&quot;; imguiLastRunTime.colour = ImColor.new(37, 194, 160) imguiLastRunTime.box_start = FFPOINT.new(25, 120, 0); -- VARIABLES_END -- METHODS_START -- Updates all the values we want to track metrics for local function calculateMetrics() lastRunTime = os.difftime(os.time(), runStartTime) runs = runs + 1 clayMined = clayMined + API.InvItemcount_1(1761) avgRunTime = math.floor(os.difftime(os.time(), scriptStartTime) / runs) runStartTime = os.time() print() print(&quot;------------------------------------------------&quot;) print(&quot;Runs: &quot; .. runs) print(&quot;Clay Mined: &quot; .. clayMined) print(&quot;Avg runtime: &quot; .. avgRunTime) print(&quot;Runs/Hr: &quot; .. math.floor(3600 / avgRunTime)) print(&quot;Runtime: &quot; .. math.floor(os.difftime(os.time(), scriptStartTime) / 60) .. &quot; minutes&quot;) end -- Draws the imgui objects to the screen local function drawMetrics() imguiClayMined.string_value = &quot;Clay Mined: &quot; .. clayMined imguiRuns.string_value = &quot;Trips: &quot; .. runs imguiLastRunTime.string_value = &quot;Last Trip: &quot; .. math.floor(lastRunTime) .. &quot;s &quot; .. &quot; Avg: &quot; .. avgRunTime .. &quot;s&quot; imguiRunsPerHr.string_value = &quot;Trips/HR: &quot; .. math.floor(3600 / avgRunTime) ImGuiTitle.string_value = &quot;Dead's Prif Clay Miner &quot; .. version .. &quot;\\n&quot; .. API.ScriptRuntimeString() API.DrawSquareFilled(imguiBackground) API.DrawTextAt(imguiRuns) API.DrawTextAt(imguiLastRunTime) API.DrawTextAt(imguiRunsPerHr) API.DrawTextAt(imguiClayMined) API.DrawTextAt(ImGuiTitle) end -- StartUp function. It runs once at the start of the script. Do stuff like doing to where you need to be and loading equipment presets here. local function onStart() print('on start') local priffLodestone = LODESTONES.LODESTONE.PRIFDDINAS.loc local playerXYZ = API.PlayerCoord() if not API.PInArea21(clayArea[1], clayArea[2], clayArea[3], clayArea[4]) and (API.Math_DistanceW(priffLodestone, playerXYZ) &gt; 50) then print('Not at clay area or in PRIFDDINAS') STATE = STATES.GOTO_PRIFF else print('Already near PRIFDDINAS lodestone') STATE = STATES.GOTO_CLAY end end local function gotoPriff() LODESTONES.Prifddinas() STATE = STATES.GOTO_CLAY end local function gotoClay() if not API.PInArea21(clayArea[1], clayArea[2], clayArea[3], clayArea[4]) then API.DoAction_WalkerW(WPOINT.new(2154, 3340, 1)) end end local function mineClay() local hoverProgress = API.LocalPlayer_HoverProgress() math.randomseed(os.time()) if hoverProgress &lt; 60 + math.random(30, 60) or not API.CheckAnim(20) then API.DoAction_Object_string1(0x3a, API.OFF_ACT_GeneralObject_route0, { &quot;Soft clay rock&quot; }, 50, true) UTILS.countTicks(2) API.WaitUntilMovingEnds() end end local function loadPreset() API.DoAction_Object_string1(0x2e, API.OFF_ACT_GeneralObject_route1, { &quot;Bank chest&quot; }, 50, true) UTILS.countTicks(2) API.WaitUntilMovingEnds() API.KeyboardPress2(bankPresetKeyCode, 50, 200) UTILS.countTicks(1) end local function emptyBags() calculateMetrics() API.DoAction_Object_string1(0x33, API.OFF_ACT_GeneralObject_route3, { &quot;Bank chest&quot; }, 50, true) UTILS.countTicks(2) API.WaitUntilMovingEnds() STATE = STATES.MINE_CLAY end local function checkStates() UTILS:gameStateChecks() UTILS:antiIdle() if not API.PInArea21(clayArea[1], clayArea[2], clayArea[3], clayArea[4]) then STATE = STATES.GOTO_CLAY elseif firstRun then loadPreset() firstRun = false elseif API.InvFull_() then STATE = STATES.EMPTY_BAGS else STATE = STATES.MINE_CLAY end end local function priffClayMiner() drawMetrics() API.DoRandomEvents() if STATE == STATES.GOTO_PRIFF then gotoPriff() elseif STATE == STATES.GOTO_CLAY then gotoClay() elseif STATE == STATES.MINE_CLAY then mineClay() elseif STATE == STATES.EMPTY_BAGS then emptyBags() end UTILS.randomSleep(600) checkStates() end -- METHODS END -- Main Loop API.Write_LoopyLoop(true) API.logWarn(&quot;Dead's Priff ClayMiner Started!&quot;) onStart() while API.Read_LoopyLoop() do priffClayMiner() end API.logWarn(&quot;Dead's Priff ClayMiner Done!&quot;) API.SetDrawTrackedSkills(false) ","keywords":"","version":"Next"},{"title":"Seren Stone Miner","type":0,"sectionRef":"#","url":"/docs/dead-prif-seren-miner","content":"Seren Stone Miner Seren Stone Miner™ 2024.02.01 Requirements​ Requirements Plague's End completed to access Prifddinas Features​ Features Automatically teleports to Prifddinas lodestone if too far away using lodestones.lua.Handles random events. + Showcases use of DoAction_WalkerW for long distance walking. + Showcases an example implementation of how a state based script can work - Doesn't log back in if it gets logged out Changelog​ Changelog 2024-02-01 Update 2.0 Now uses the updated UTIL functionsCode cleanup 2023.08.30 Release Release Code​ Code --[[ # Script Name: Dead's Prifddinas Seren Stone Miner # Description: &lt;Mines Seren Stones at Prifddinas.&gt; # Autor: &lt;Dead (dea.d - Discord)&gt; # Version: &lt;2.0&gt; # Datum: &lt;2024.02.01&gt; --]] print(&quot;Run Priff Seren Stones Miner.&quot;) local version = &quot;2.0&quot; --#region INCLUDES local API = require(&quot;api&quot;) local LODESTONES = require(&quot;lodestones&quot;) local UTILS = require(&quot;utils&quot;) --#endregion API.SetDrawTrackedSkills(true) API.SetDrawLogs(true) --#region VARIABLES local startXP = API.GetSkillXP(&quot;MINING&quot;); local stateXp = startXP; local forceMine = false; local noXpGainTick = 0; -- The X1,X2,Y1,Y2 coords of the rectangle that we consider to be the area in which stones are interactable. local miningArea = { 2206, 2247, 3208, 3322 } -- We update this value based on the state transitions local STATE = 0 -- All the states that we want to track local STATES = { GOTO_STONES = 0, MINE_STONES = 1, GOTO_PRIFF = 3 } -- Draws the black background local imguiBackground = API.CreateIG_answer(); imguiBackground.box_name = &quot;ImguiBackground&quot; imguiBackground.box_start = FFPOINT.new(20, 40, 0) imguiBackground.box_size = FFPOINT.new(220, 80, 0) imguiBackground.colour = ImColor.new(10, 13, 29) local ImGuiTitle = API.CreateIG_answer() ImGuiTitle.box_start = FFPOINT.new(25, 45, 0) ImGuiTitle.colour = ImColor.new(37,194,160) ImGuiTitle.string_value = &quot;Dead's Prif Seren Miner &quot; .. version --#endregion --#region METHODS -- Draws the imgui objects to the screen local function drawMetrics() local xpGained = API.GetSkillXP(&quot;MINING&quot;) - stateXp; API.DrawSquareFilled(imguiBackground) ImGuiTitle.string_value = &quot;Dead's Prif Seren Miner &quot; .. version .. &quot;\\n&quot; .. API.ScriptRuntimeString() API.DrawTextAt(ImGuiTitle) if xpGained &gt; 0 then stateXp = stateXp + xpGained; noXpGainTick = 0; else noXpGainTick = noXpGainTick + 1; end end local function gameStateChecks() UTILS.gameStateChecks() if noXpGainTick &gt; 30 then API.logError('Not gaining xp, exiting') print('Not gaining xp') API.Write_LoopyLoop(false) end end local function onStart() print('on start') local priffLodestone = LODESTONES.LODESTONE.PRIFDDINAS.loc local playerXYZ = API.PlayerCoord() if not API.PInArea21(miningArea[1], miningArea[2], miningArea[3], miningArea[4]) and (API.Math_DistanceW(priffLodestone, playerXYZ) &gt; 50) then print('Not at stones area or in PRIFDDINAS') STATE = STATES.GOTO_PRIFF else print('Already near PRIFDDINAS lodestone') STATE = STATES.GOTO_STONES end end local function gotoPriff() LODESTONES.Prifddinas() STATE = STATES.GOTO_STONES end local function gotoStones() if not API.PInArea21(miningArea[1], miningArea[2], miningArea[3], miningArea[4]) then API.DoAction_WalkerW(WPOINT.new(2232, 3310, 1)) end STATE = STATES.MINE_STONES end local function mineStones() if not API.CheckAnim(20) then API.DoAction_Object_string1(0x3a, API.OFF_ACT_GeneralObject_route0, { &quot;Seren stone&quot; }, 50, true) UTILS.randomSleep(600) API.WaitUntilMovingEnds() else if forceMine then API.logInfo('Force Mine') API.DoAction_Object_string1(0x3a, API.OFF_ACT_GeneralObject_route0, { &quot;Seren stone&quot; }, 50, true) UTILS.randomSleep(600) forceMine = false end end end local function priffSerenMiner() gameStateChecks() drawMetrics() API.DoRandomEvents() if UTILS:antiIdle() then forceMine = true end if STATE == STATES.GOTO_PRIFF then gotoPriff() elseif STATE == STATES.GOTO_STONES then gotoStones() elseif STATE == STATES.MINE_STONES then mineStones() end UTILS.randomSleep(600) end --#endregion -- Main Loop API.Write_LoopyLoop(true) API.logWarn(&quot;Dead's Priff Seren Stones Started!&quot;) onStart() while API.Read_LoopyLoop() do priffSerenMiner() end API.logWarn(&quot;Dead's Priff Seren Stones Done!&quot;) API.SetDrawTrackedSkills(false) ","keywords":"","version":"Next"},{"title":"DeadAuras","type":0,"sectionRef":"#","url":"/docs/dead-aura","content":"DeadAuras Dead Auras™ 2024.01 Usage​ Usage local AURAS = require(&quot;deadAuras&quot;) AURAS.GREENFINGERS:activate() Changelog​ Changelog 2024-01-20 Release [1.0] Release Code​ Code local API = require(&quot;api&quot;) local AURAS = {} local auraTitleInterface = { InterfaceComp5.new(1929, 0, -1, -1, 0), InterfaceComp5.new(1929, 2, -1, 0, 0), InterfaceComp5.new(1929, 2, 14, 2, 0), } local auraStatusTextInterface = { InterfaceComp5.new(1929, 0, -1, -1, 0), InterfaceComp5.new(1929, 3, -1, 0, 0), InterfaceComp5.new(1929, 4, -1, 3, 0), InterfaceComp5.new(1929, 74, -1, 4, 0), } local buttonTextInterface = { InterfaceComp5.new(1929, 0, -1, -1, 0), InterfaceComp5.new(1929, 3, -1, 0, 0), InterfaceComp5.new(1929, 4, -1, 3, 0), InterfaceComp5.new(1929, 6, -1, 4, 0), InterfaceComp5.new(1929, 11, -1, 6, 0), InterfaceComp5.new(1929, 18, -1, 11, 0), InterfaceComp5.new(1929, 19, -1, 18, 0), } local auraOverridePopup = { InterfaceComp5.new(1929, 0, -1, -1, 0), InterfaceComp5.new(1929, 3, -1, 0, 0), InterfaceComp5.new(1929, 142, -1, 3, 0), InterfaceComp5.new(1929, 144, -1, 142, 0), InterfaceComp5.new(1929, 166, -1, 144, 0), InterfaceComp5.new(1929, 166, 14, 166, 0), } local CONSTANTS = { BUTTON_BUY = &quot;Buy&quot;, BUTTON_ACTIVATE = &quot;Activate&quot;, BUTTON_DEACTIVATE = &quot;Deactivate&quot;, AURA_MANAGEMENT = &quot;Aura Management&quot;, READY = &quot;Ready to use&quot;, RECHARGING = &quot;Currently recharging&quot;, ACTIVE = &quot;Currently active&quot;, } local function doesStringInclude(input, searchValue) return string.find(tostring(input), searchValue) ~= nil end local function waitUntil(x, timeout) local start = os.time() while not x() and start + timeout &gt; os.time() do API.RandomSleep2(200, 200, 200) end return start + timeout &gt; os.time() end local function isInterfaceVisible(interface, nested) local inter = API.ScanForInterfaceTest2Get(nested, interface) if (#inter &gt; 0 ) then print('visible', inter[1].textids) if inter[1].x &gt; 0 then return true end end return false end local function getInterfaceText(interface, nested) local inter = API.ScanForInterfaceTest2Get(nested, interface) if (#inter &gt; 0) then return inter[1].textids else return nil end end local function getButtonText() return getInterfaceText(buttonTextInterface, false) end local function canUseAura() -- select the aura here local status = getInterfaceText(auraStatusTextInterface, false) local inter = API.ScanForInterfaceTest2Get(false, auraStatusTextInterface) if (#inter &gt; 0) then local status = inter[1].textids if (string.len(status) &gt; 0) and doesStringInclude(status, CONSTANTS.READY) then return true else return false end else return false end end local function isAuraInterfaceOpen() local inter = API.ScanForInterfaceTest2Get(false, auraTitleInterface) if (#inter &gt; 0) then local status = inter[1].textids if (string.len(status) &gt; 0) and (doesStringInclude(status, CONSTANTS.AURA_MANAGEMENT)) then return true else return false end else return false end end function AURAS.openAuraInterface() if isAuraInterfaceOpen() then return end local auraEquipped = AURAS.isAuraEquipped() print('auraEquipped', auraEquipped) if (auraEquipped) then print('aura equipped, going in') local auraId = API.GetEquipSlot(11).itemid1 API.DoAction_Interface(0xffffffff, auraId, 2, 1464, 15, 14, API.OFF_ACT_GeneralInterface_route) else print('no aura equipped') API.DoAction_Interface(0xffffffff, 0xffffffff, 1, 1464, 15, 14, API.OFF_ACT_GeneralInterface_route) end end function AURAS.closeAuraInterface() API.DoAction_Interface(0x24, 0xffffffff, 1, 1929, 167, -1, API.OFF_ACT_GeneralInterface_route) end local function openEquipmentInterface() API.DoAction_Interface(0xc2, 0xffffffff, 1, 1432, 5, 2, API.OFF_ACT_GeneralInterface_route) end local function isEquipmentInterfaceOpen() return API.VB_FindPSett(3074).SumOfstate == 1 end function AURAS.isAuraEquipped() local equipmentOpen = isEquipmentInterfaceOpen() if not equipmentOpen then openEquipmentInterface() end local equipped = false if API.GetEquipSlot(11).itemid1 == -1 then equipped = false else equipped = true end if not equipmentOpen then openEquipmentInterface() end return equipped end local function selectAura(auraIds, force) if (not AURAS.isAuraEquipped()) and force then print('already have an aura, no force') return end for index, value in ipairs(auraIds) do API.DoAction_Interface(0xffffffff, auraIds[index][1], 1, 1929, 95, auraIds[index][2], API.OFF_ACT_GeneralInterface_route) API.RandomSleep2(1200, 100, 300) local btnText = getButtonText() if doesStringInclude(btnText, CONSTANTS.BUTTON_DEACTIVATE) then print('aura already active') break end if (canUseAura()) then if doesStringInclude(btnText, CONSTANTS.BUTTON_ACTIVATE) then API.DoAction_Interface(0x24, 0xffffffff, 1, 1929, 16, -1, API.OFF_ACT_GeneralInterface_route) API.RandomSleep2(1200, 100, 300) if AURAS.isAuraEquipped() and force then print('force use') API.DoAction_Interface(0x24,0xffffffff,1,1929,162,-1,API.OFF_ACT_GeneralInterface_route) API.RandomSleep2(800, 100, 300) AURAS.closeAuraInterface() end break else print('have aura but cant use') end else print('dont have aura') end end end local function activateAura(auraIds, force) local auraInterfaceOpened = isAuraInterfaceOpen() if not auraInterfaceOpened then AURAS.openAuraInterface() end if not waitUntil(isAuraInterfaceOpen, 10) then print('Aura interface wasnt open after 10 seconds, exiting') return end selectAura(auraIds, force) if not auraInterfaceOpened then AURAS.openAuraInterface() end end AURAS.ODDBALL = { ids = { { 20957, 0 } }, activate = function(force) activateAura(0, force) end } AURAS.FESTIVE = { ids = { { 26120, 88 } }, activate = function(force) activateAura(0, force) end } AURAS.POISON_PURGE = { ids = { { 23862, 67 }, { 22917, 48 }, { 22268, 10 }, { 20958, 1 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.FRIEND_IN_NEED = { ids = { { 20963, 2 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.KNOCK_OUT = { ids = { { 22933, 53 }, { 20961, 3 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.SHARP_SHOOTER = { ids = { { 23866, 69 }, { 22921, 50 }, { 22272, 12 }, { 20967, 4 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.RUNIC_ACCURACY = { ids = { { 23864, 68 }, { 22919, 49 }, { 22270, 11 }, { 20962, 5 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.SUREFOOTED = { ids = { { 22278, 15 }, { 20964, 6 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.REVERENCE = { ids = { { 23870, 71 }, { 22925, 52 }, { 22276, 14 }, { 20965, 7 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.CALL_OF_THE_SEA = { ids = { { 30794, 74 }, { 23868, 70 }, { 22923, 51 }, { 22274, 13 }, { 20966, 8 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.LUMBERJACK = { ids = { { 30796, 75 }, { 23860, 66 }, { 22915, 47 }, { 22282, 17 }, { 22280, 16 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.QUARRYMASTER = { ids = { { 30800, 77 }, { 23858, 65 }, { 22913, 46 }, { 22286, 19 }, { 22284, 18 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.FIVE_FINGER_DISCOUNT = { ids = { { 30798, 76 }, { 23856, 64 }, { 22911, 45 }, { 22290, 21 }, { 22288, 20 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.RESOURCEFUL = { ids = { { 22292, 22 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.EQUILIBRIUM = { ids = { { 22294, 23 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.INSPIRATION = { ids = { { 22296, 24 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.PENANCE = { ids = { { 22300, 26 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.WISDOM = { ids = { { 35832, 27 }, { 35830, 27 }, { 22302, 27 } }, -- MISSING???? activate = function(self, force) activateAura(self.ids, force) end } AURAS.AEGIS = { ids = { { 22889, 28 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.REGENERATION = { ids = { { 22893, 29 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.DARK_MAGIC = { ids = { { 22891, 30 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.BERSERKER = { ids = { { 22897, 31 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.ANCESTOR_SPIRITS = { ids = { { 22895, 32 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.TRACKER = { ids = { { 30802, 78 }, { 23872, 72 }, { 22931, 38 }, { 22929, 37 }, { 22927, 36 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.SALVATION = { ids = { { 23876, 54 }, { 22903, 41 }, { 22901, 40 }, { 22899, 39 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.CORRUPTION = { ids = { { 23874, 55 }, { 22909, 44 }, { 22907, 43 }, { 22905, 42 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.HARMONY = { ids = { { 23854, 59 }, { 23852, 58 }, { 23850, 57 }, { 23848, 56 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.INVIGORATE = { ids = { { 23846, 63 }, { 23844, 62 }, { 23842, 61 }, { 23840, 60 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.GREENFINGERS = { ids = { { 30804, 79 }, { 23878, 73 }, { 22887, 35 }, { 22885, 34 }, { 22883, 33 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.ENRICHMENT = { ids = { { 30792, 84 }, { 30790, 83 }, { 30788, 82 }, { 30786, 81 }, { 30784, 80 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.BRAWLER = { ids = { { 35792, 92 }, { 35790, 91 }, { 35788, 90 }, { 35786, 89 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.RECKLESS = { ids = { { 35794, 93 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.MANIACAL = { ids = { { 35796, 94 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.DEDICATED_SLAYER = { ids = { { 35806, 99 }, { 35804, 98 }, { 35802, 97 }, { 35800, 96 }, { 35798, 95 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.FOCUSED_SIPHONING = { ids = { { 35816, 104 }, { 35814, 103 }, { 35812, 102 }, { 35810, 101 }, { 35808, 100 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.FLAMEPROOF = { ids = { { 35826, 108 }, { 35824, 107 }, { 35820, 106 }, { 35818, 105 } }, activate = function(self, force) activateAura(self.ids, force) end } AURAS.JACK_OF_TRADES = { ids = { { 35828, 110 }, { 30808, 86 }, { 30806, 85 }, { 20959, 9 } }, activate = function(self, force) activateAura(self.ids, force) end } return AURAS ","keywords":"","version":"Next"},{"title":"Tree Chopper","type":0,"sectionRef":"#","url":"/docs/dead-prif-trees","content":"Tree Chopper Tree Chopper™ 2024.02.01 Requirements​ Requirements Plague's End completed to access Prifddinas Features​ Features Automatically teleports to Prifddinas lodestone if too far away using lodestones.lua.Handles random events.Recommended to have wood box in inventory to store nests + Showcases use of DoAction_WalkerW for long distance walking. + Counts number of logs chopped - Doesn't log back in if it gets logged out - Doesn't deposit logs into wood box Configuration​ Configuration Set the keycode of the bank preset you want to use [bankPresetKeycode] Follow this link to know what keycodes to use Changelog​ Changelog 2024-02-01 Update 2.0 Added dropdown to select which tree to chopNow uses the updated UTIL functionsCode cleanup 2023-09-24 Release Release Code​ Code --[[ # Script Name: Dead's Prifddinas Tree Chopper # Description: &lt;Chops trees at Crwys Clan.&gt; # Autor: &lt;Dead (dea.d - Discord)&gt; # Version: &lt;1.0&gt; # Datum: &lt;2023.09.24&gt; #Changelog - 2023.09.24 [1.0] Release #Requirements: Plague's End completed to access Prifddinas #Instructions: &gt; Set the name of the tree to chop [treeToChop] &gt; Set the name of the logs you receive [logsToCount] &gt; Set the keycode of the bank preset you want to use [bankPresetKeyCode] https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes --]] print(&quot;Run Dead's Priff Tree Chopper.&quot;) local version = &quot;2.0&quot; --#region INCLUDES local API = require(&quot;api&quot;) local LODESTONES = require(&quot;lodestones&quot;) local UTILS = require(&quot;utils&quot;) --#endregion API.SetDrawTrackedSkills(true) API.SetDrawLogs(true) --#region VARIABLES local bankPresetKeyCode = 0x72 -- https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes local imguiBackground = API.CreateIG_answer() imguiBackground.box_name = &quot;ImguiBackground&quot; imguiBackground.box_start = FFPOINT.new(20, 40, 0) imguiBackground.box_size = FFPOINT.new(235, 120, 0) imguiBackground.colour = ImColor.new(10, 13, 29) local imguiTitle = API.CreateIG_answer() imguiTitle.box_name = &quot;imguiLogsChopped&quot;; imguiTitle.box_start = FFPOINT.new(25, 45, 0) imguiTitle.colour = ImColor.new(138, 186, 168) imguiTitle.string_value = &quot;Dead's Priff Tree Chopper &quot; .. version local imguiDropdown = API.CreateIG_answer() imguiDropdown.box_name = &quot;Trees&quot; imguiDropdown.box_start = FFPOINT.new(18, 70, 0) imguiDropdown.box_size = FFPOINT.new(235, 90, 0) imguiDropdown.stringsArr = {&quot;Magic&quot;, &quot;Yew&quot;} imguiDropdown.colour = ImColor.new(138, 186, 168) local treeToChop = &quot;Magic tree&quot; local logsToCount = &quot;Magic logs&quot; local logs = 0 local imguiLogs = API.CreateIG_answer() imguiLogs.box_name = &quot;imguiLogs&quot;; imguiLogs.box_start = FFPOINT.new(25, 100, 0) imguiLogs.colour = ImColor.new(138, 186, 168) imguiLogs.string_value = logsToCount .. &quot; chopped : &quot; .. tostring(logs) --#endregion local firstRun = true local tickCount = 0 local STATE = 0 local STATES = { GOTO_BANK = 0, BANK = 1, GOTO_TREES = 2, CHOP = 3 } local function drawGUI() imguiTitle.string_value = &quot;Dead's Priff Tree Chopper &quot; .. version .. &quot;\\n&quot; .. API.ScriptRuntimeString() imguiLogs.string_value = logsToCount .. &quot; chopped : &quot; .. tostring(logs) API.DrawSquareFilled(imguiBackground) API.DrawComboBox(imguiDropdown, false) API.DrawTextAt(imguiTitle) API.DrawTextAt(imguiLogs) end --#endregion local function onStart() print('on start') local priffLodestone = LODESTONES.LODESTONE.PRIFDDINAS.loc local playerXYZ = API.PlayerCoord() if (API.Math_DistanceW(priffLodestone, playerXYZ) &gt; 68) then print('They are different') LODESTONES.Prifddinas() UTILS.randomSleep(6000) else print('Already near PRIFDDINAS lodestone') end if API.Invfreecount_() &lt; 24 then STATE = STATES.BANK else STATE = STATES.GOTO_TREES end end local function bank() if firstRun then API.DoAction_WalkerW(WPOINT.new(2240, 3384, 1)) UTILS.randomSleep(800) API.WaitUntilMovingEnds() API.DoAction_Object2(0x2e, API.OFF_ACT_GeneralObject_route1, {92692}, 50, WPOINT.new(2237,3385,1)) UTILS.randomSleep(600) API.WaitUntilMovingEnds() if API.BankOpen2() then API.KeyboardPress2(bankPresetKeyCode,100,300) UTILS.randomSleep(600) firstRun = false STATE = STATES.CHOP end else local invLogsCount = API.InvItemcount_String(logsToCount) logs = logs + invLogsCount imguiTitle.string_value = &quot;Dead's Priff Tree Chopper\\n&quot; .. API.ScriptRuntimeString() API.DoAction_Object2(0x33, API.OFF_ACT_GeneralObject_route3, { 92692 }, 50,WPOINT.new(2237,3385,1)) UTILS.randomSleep(2000) API.WaitUntilMovingEnds() UTILS.randomSleep(800) STATE = STATES.CHOP end end local function gotoTrees() API.DoAction_WalkerW(WPOINT.new(2246, 3367, 1)) UTILS.randomSleep(1200) API.WaitUntilMovingEnds() if not API.PInAreaW(WPOINT.new(2245, 3367, 1), 30) then STATE = STATES.GOTO_TREES else STATE = STATES.CHOP end end local function CHOP(tableTree) if not API.InventoryInterfaceCheckvarbit() then API.OpenInventoryInterface2() UTILS.randomSleep(600) end local trees = API.GetAllObjArrayInteract_str(tableTree, 50, 0) local validTrees = {} tickCount = tickCount + 1 for i = 1, #trees do local tree = trees[i] if tree.Bool1 == 0 then table.insert(validTrees, tree) end end if #validTrees &gt; 0 then local tree = validTrees[math.random(1,#validTrees)] if not API.CheckAnim(20) or not API.WaitUntilMovingEnds() and trees[1] ~= nil then API.DoAction_Object2(0x3b, 0, { tree.Id }, 50, WPOINT.new(tree.TileX / 512, tree.TileY / 512, 1)) UTILS.randomSleep(1200) API.WaitUntilMovingEnds() tickCount = 0 end end end local function inventoryCheck() if API.Invfreecount_() == 0 then STATE = STATES.BANK; end end local function PrifChopper(tableTree) UTILS.gameStateChecks() UTILS:antiIdle() API.DoRandomEvents() drawGUI() inventoryCheck() if STATE == STATES.BANK then bank() elseif STATE == STATES.GOTO_TREES then gotoTrees() elseif STATE == STATES.CHOP then CHOP(tableTree) end end API.logWarn(&quot;Dead's Priff Chopper Started!&quot;) if (API.Read_LoopyLoop()) then print(&quot;Dead Priff Chopper Started!&quot;) onStart() while API.Read_LoopyLoop() do if imguiDropdown.int_value == 0 then if treeToChop ~= &quot;Magic tree&quot; then treeToChop = &quot;Magic tree&quot; logsToCount = &quot;Magic logs&quot; end elseif imguiDropdown.int_value == 1 then if treeToChop ~= &quot;Yew&quot; then treeToChop = &quot;Yew&quot; logsToCount = &quot;Yew logs&quot; end end PrifChopper({treeToChop}) end end API.logWarn(&quot;Dead's Priff Chopper Stopped!&quot;) API.SetDrawTrackedSkills(false) ","keywords":"","version":"Next"},{"title":"Interfaces","type":0,"sectionRef":"#","url":"/docs/Guides/ME/interfaces","content":"Interfaces How do you find interfaces in ME?","keywords":"","version":"Next"},{"title":"Dead Codes","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Dead Codes","url":"/docs/intro#getting-started","content":" Get started by creating a new site.  Or try Docusaurus immediately with docusaurus.new.  ","version":"Next","tagName":"h2"},{"title":"What you'll need​","type":1,"pageTitle":"Dead Codes","url":"/docs/intro#what-youll-need","content":" Node.js version 18.0 or above: When installing Node.js, you are recommended to check all checkboxes related to dependencies.  ","version":"Next","tagName":"h3"},{"title":"Generate a new site​","type":1,"pageTitle":"Dead Codes","url":"/docs/intro#generate-a-new-site","content":" Generate a new Docusaurus site using the classic template.  The classic template will automatically be added to your project after you run the command:  npm init docusaurus@latest my-website classic   You can type this command into Command Prompt, Powershell, Terminal, or any other integrated terminal of your code editor.  The command also installs all necessary dependencies you need to run Docusaurus.  ","version":"Next","tagName":"h2"},{"title":"Start your site​","type":1,"pageTitle":"Dead Codes","url":"/docs/intro#start-your-site","content":" Run the development server:  cd my-website npm run start   The cd command changes the directory you're working with. In order to work with your newly created Docusaurus site, you'll need to navigate the terminal there.  The npm run start command builds your website locally and serves it through a development server, ready for you to view at http://localhost:3000/.  Open docs/intro.md (this page) and edit some lines: the site reloads automatically and displays your changes. ","version":"Next","tagName":"h2"},{"title":"DeadSlayer","type":0,"sectionRef":"#","url":"/docs/dead-slayer","content":"DeadSlayer Dead Slayer™ 2023.09 Features​ Features Uses Augmented Enhanced Excalibur if found in inventory and health below 50%Uses Elven Ritual Shard if found in inventory and prayer below 50%Uses the Eat Food skill if available and Excalibur is on cooldown and health below 50%If unable to heal and health falls below 20%, uses Wars Retreat teleport and exits Requirements​ Requirements Eat Food skill on Action bar Script Execution​ Script Execution Click the [GET] button to populate the dropdown with list of mobsClick the [SET] button to set the targetClick [Slaughter] to start, it flips over to [Pause] to pauseClick [Stop] script to exit Changelog​ Changelog 2023-09-21 Features [1.1] Added CheckForAnim to handle channeled abilitiesAdded longer delays before clicking next mob 2023-09-21 Release [1.0] Release Code​ Code local ITEMS = {} ITEMS.COMMON = { 995 -- gold coins } ITEMS.RUNES = { 554, -- fire 555, -- water 556, -- air 557 -- earth } ITEMS.HERBS = { 21626, -- fellstalk 48243, -- arbuck 219, -- torstol 217, -- dwarf weed 2485, -- lantadyme 215, -- cadantine 3051, -- snapdragon 37975, -- bloodweed 213, -- kwuarm 14836, -- wergali 12174, -- spirit weed 3049, -- toadflax 207, -- ranarr 201 -- marrentill } ITEMS.BONES = { 35010, -- reinforced dragon 3123, -- shaikahan 4834, -- ourg 35008, -- hardened dragon 18832, -- frost dragon 30209, -- airut 6812, -- wyvern 48075, -- dinosaur 51858, -- dragonkin 4832, -- raurg 6729, -- dagannoth 4830, -- fayrg 2859, -- wolf 536, -- dragon 4812, -- zogre 530, -- bat 534, -- baby dragon 528, -- burnt 526, -- bones 3125 -- jogre } ITEMS.ASHES = { 34159, -- searing 33260, -- tortured 20268, -- infernal 20266, -- accursed 20264 -- impious } ITEMS.ARROWS = { 892 -- rune arrows } ITEMS.CHARMS = { 12158, -- gold, 12159, -- green 12160, -- crimson 12163, -- blue, 12161 -- abyssal } print(&quot;Run DeadSlayer.&quot;) local API = require(&quot;api&quot;) local UTILS = require(&quot;utils&quot;) local buryBones = true --Set this to true to bury bones that you pickup local bonesId = ITEMS.BONES --IDS of the bones to bury local itemIdsToLoot = UTILS.concatenateTables( --IDS of the items to loot ITEMS.COMMON, ITEMS.RUNES, ITEMS.BONES, ITEMS.ARROWS, ITEMS.CHARMS) -- #region User Inputs -- #endregion -- #region Imgui Setup local imguiBackground = API.CreateIG_answer(); imguiBackground.box_name = &quot;imguiBackground&quot;; imguiBackground.box_start = FFPOINT.new(16, 20, 0); imguiBackground.box_size = FFPOINT.new(300, 116, 0) local getTargetBtn = API.CreateIG_answer(); getTargetBtn.box_name = &quot;Get&quot;; getTargetBtn.box_start = FFPOINT.new(16, 20, 0); getTargetBtn.box_size = FFPOINT.new(50, 30, 0); getTargetBtn.tooltip_text = &quot;Populate mobs list&quot; local setTargetBtn = API.CreateIG_answer(); setTargetBtn.box_name = &quot;Set&quot;; setTargetBtn.box_start = FFPOINT.new(60, 20, 0); setTargetBtn.box_size = FFPOINT.new(50, 30, 0); setTargetBtn.tooltip_text = &quot;The script will kill this mob&quot; local imguicombo = API.CreateIG_answer() imguicombo.box_name = &quot;Mobs &quot; imguicombo.box_start = FFPOINT.new(100, 20, 0) imguicombo.stringsArr = {&quot;a&quot;, &quot;b&quot;} imguicombo.tooltip_text = &quot;Available mobs to target&quot; local imguiCurrentTarget = API.CreateIG_answer(); imguiCurrentTarget.box_name = &quot;Current Target:&quot;; imguiCurrentTarget.box_start = FFPOINT.new(30, 50, 0); local imguiSlaughter = API.CreateIG_answer(); imguiSlaughter.box_name = &quot;Slaughter&quot;; imguiSlaughter.box_start = FFPOINT.new(18, 60, 0); imguiSlaughter.box_size = FFPOINT.new(80, 30, 0); imguiSlaughter.tooltip_text = &quot;Start/Stop slaying&quot; local imguiTerminate = API.CreateIG_answer(); imguiTerminate.box_name = &quot;Stop Script&quot;; imguiTerminate.box_start = FFPOINT.new(100, 60, 0); imguiTerminate.box_size = FFPOINT.new(100, 30, 0); imguiTerminate.tooltip_text = &quot;Exit the script&quot; local imguiRuntime = API.CreateIG_answer(); imguiRuntime.box_name = &quot;imguiRuntime&quot;; imguiRuntime.box_start = FFPOINT.new(30, 90, 0); API.DrawComboBox(imguicombo, false) -- #endregion -- #region Variables init local startTime = os.time() local idleTime = os.time() local targetPlaceholder = &quot;None. Click Set Mob&quot; local target = targetPlaceholder local runSlayer = false local targetNotFoundCount = 0 local IDS = { EXCALIBUR = 14632, EXCALIBUR_AUGMENTED = 36619, ELVEN_SHARD = 43358 } local COLORS = { BACKGROUND = ImColor.new(10, 13, 29), TARGET_UNSET = ImColor.new(189, 185, 167), TARGET_SET = ImColor.new(70, 143, 126), SLAUGHTER = ImColor.new(84, 166, 102), PAUSED = ImColor.new(238, 59, 83), RUNTIME = ImColor.new(198, 120, 102) } imguiBackground.colour = COLORS.BACKGROUND imguiCurrentTarget.colour = COLORS.TARGET_UNSET imguiRuntime.colour = COLORS.SLAUGHTER -- #endregion -- #region Util functions local function log(text) print(string.format(&quot;%s - %s&quot;, os.date(&quot;[%H:%M:%S]&quot;), text)) end local function antiIdleTask() local timeDiff = os.difftime(os.time(), idleTime) local randomTime = math.random((5 * 60) * 0.6, (5 * 60) * 0.9) if timeDiff &gt; randomTime then API.PIdle2() idleTime = os.time() end end local function formatElapsedTime(start) local currentTime = os.time() local elapsedTime = currentTime - start local hours = math.floor(elapsedTime / 3600) local minutes = math.floor((elapsedTime % 3600) / 60) local seconds = elapsedTime % 60 return string.format(&quot;Runtime: %02d:%02d:%02d&quot;, hours, minutes, seconds) end local function gameStateChecks() local gameState = API.GetGameState() if (gameState ~= 3) then API.log('Not ingame with state:', gameState) API.Write_LoopyLoop(false) return end if targetNotFoundCount &gt; 30 then imguiSlaughter.box_name = &quot;Slaughter&quot; runSlayer = false; API.Write_LoopyLoop(false) end end local function terminate() runSlayer = false API.Write_LoopyLoop(false) end -- #endregion -- #region UI render functions local function populateDropdown() log('populateDropdown') local allNPCS = API.ReadAllObjectsArray(false, 1) local mobs = {} if #allNPCS &gt; 0 then for _, a in pairs(allNPCS) do local distance = API.Math_DistanceF(a.Tile_XYZ, API.PlayerCoordfloat()) a.Distance = distance; if a.Id ~= 0 and a.Life &gt; 1 and distance &lt; 50 then table.insert(mobs, a.Name) end end local distinct = UTILS.getDistinctValues(mobs) if #distinct &gt; 0 then table.sort(distinct) imguicombo.stringsArr = distinct end end end local function setMob() log('setMob') local currentMob = target; local selected = imguicombo.stringsArr[imguicombo.int_value + 1] if currentMob ~= selected then target = selected; end imguiCurrentTarget.colour = COLORS.TARGET_SET setTargetBtn.return_click = false; end local function pauseSlayer() runSlayer = false log(&quot;Slayer paused&quot;) imguiSlaughter.return_click = false imguiCurrentTarget.colour = COLORS.PAUSED imguiRuntime.colour = COLORS.PAUSED imguiSlaughter.box_name = &quot;Slaughter&quot; end local function startSlayer() log(&quot;Slayer started&quot;) runSlayer = true; imguiCurrentTarget.colour = COLORS.SLAUGHTER imguiRuntime.colour = COLORS.SLAUGHTER imguiSlaughter.box_name = &quot;Pause&quot; end local function drawGUI() if imguiTerminate.return_click then terminate() end if imguiSlaughter.return_click then if not runSlayer then startSlayer() end else if runSlayer then pauseSlayer() end end if getTargetBtn.return_click then populateDropdown() getTargetBtn.return_click = false end if not runSlayer and setTargetBtn.return_click then setMob() end API.DrawSquareFilled(imguiBackground) API.DrawBox(setTargetBtn) API.DrawBox(getTargetBtn) imguiCurrentTarget.string_value = &quot;Current target:&quot; .. target imguiRuntime.string_value = formatElapsedTime(startTime) -- os.difftime(os.time(),startTime) API.DrawBox(imguiSlaughter) API.DrawBox(imguiTerminate) API.DrawTextAt(imguiCurrentTarget) API.DrawTextAt(imguiRuntime) end -- #endregion -- #region Script functions local function buryBones() while API.InvItemFound2(bonesId) do if not API.Read_LoopyLoop() or not API.PlayerLoggedIn() then break end API.DoAction_Inventory2(bonesId, 0, 1, API.OFF_ACT_GeneralInterface_route) UTILS.randomSleep(600) end end local function loot() -- print(UTILS.printTable(itemIdsToLoot)) if not API.InvFull_() then log('looting') API.DoAction_Loot_w(itemIdsToLoot, 10, API.PlayerCoordfloat(), 10) UTILS.randomSleep(600) API.WaitUntilMovingEnds() else buryBones() end end local function healthCheck() local hp = API.GetHPrecent() local prayer = API.GetPrayPrecent() local excalCD = API.DeBuffbar_GetIDstatus(IDS.EXCALIBUR, false) local excalFound = API.InvItemcount_1(IDS.EXCALIBUR_AUGMENTED) local elvenCD = API.DeBuffbar_GetIDstatus(IDS.ELVEN_SHARD, false) local elvenFound = API.InvItemcount_1(IDS.ELVEN_SHARD) local eatFoodAB = API.GetABs_name1(&quot;Eat Food&quot;) if hp &lt; 50 then if not excalCD.found and excalFound &gt; 0 then log(&quot;Using Excalibur&quot;) API.DoAction_Inventory1(IDS.EXCALIBUR_AUGMENTED, 0, 2, API.OFF_ACT_GeneralInterface_route) UTILS.randomSleep(800) else if eatFoodAB.id ~= 0 and eatFoodAB.enabled then log(&quot;Eating&quot;) API.DoAction_Ability_Direct(eatFoodAB, 1, API.OFF_ACT_GeneralInterface_route) UTILS.randomSleep(600) elseif hp &lt; 20 then log(&quot;Health critical, unable to heal, running away&quot;) API.DoAction_Ability(&quot;Retreat Teleport&quot;, 1, API.OFF_ACT_GeneralInterface_route) terminate() end end end if prayer &lt; 50 and not elvenCD.found and elvenFound &gt; 0 then log(&quot;Using Elven Shard&quot;) API.DoAction_Inventory1(IDS.ELVEN_SHARD, 43358, 1, API.OFF_ACT_GeneralInterface_route) UTILS.randomSleep(600) end end local function useSkills() end local function usePrayers() end local function hasTarget() local interacting = API.ReadLpInteracting() if interacting.Id ~= 0 then return true else return false end end local function getDistinctByProperty(inputTable, property) local distinctValues = {} local seenValues = {} for _, value in ipairs(inputTable) do local prop = value[property] if not seenValues[prop] then table.insert(distinctValues, value) seenValues[prop] = true end end return distinctValues end local function filterByHealth(mobs, minHealth) local result = {} for _, mob in ipairs(mobs) do if mob.Life &gt;= minHealth then table.insert(result, mob) end end return result end local function KillMob(name) if name == targetPlaceholder then log('No target selected, stopping slayer'); pauseSlayer() end if not hasTarget() and not API.CheckAnim(15) then loot() local attackingMe = API.OthersInteractingWithLpNPC(true, 10) if #attackingMe &gt; 0 then -- if attackingMe[1].Name == target then API.DoAction_NPC__Direct(0x2a, API.OFF_ACT_AttackNPC_route, attackingMe[1]) UTILS.randomSleep(600) targetNotFoundCount = 0 -- end else local targets = API.GetAllObjArrayInteract_str({name}, 30, 1) if #targets &gt; 0 then table.sort(targets, function(k1, k2) return k1.Distance &lt; k2.Distance end) local alive = filterByHealth(targets,1) if API.DoAction_NPC__Direct(0x2a, API.OFF_ACT_AttackNPC_route, alive[1]) then targetNotFoundCount = 0 UTILS.randomSleep(600) API.WaitUntilMovingEnds() end -- if API.DoAction_NPC_str(0x2a, API.OFF_ACT_AttackNPC_route, { name }, 40, false, 50) then -- UTILS.randomSleep(600) -- API.WaitUntilMovingEnds() -- targetNotFoundCount = 0 else log('unable to find target') targetNotFoundCount = targetNotFoundCount + 1 UTILS.randomSleep(600) end end else healthCheck() useSkills() usePrayers() end end -- #endregion -- #region Main loop API.Write_LoopyLoop(true) populateDropdown() while (API.Read_LoopyLoop()) do ----------------------------------------------------------------------------------- API.DoRandomEvents() gameStateChecks() antiIdleTask() drawGUI() if runSlayer then KillMob(target) end UTILS.randomSleep(300) end ---------------------------------------------------------------------------------- -- #endregion Credits​ Credits Alar​ Contribution - Gave us ME","keywords":"","version":"Next"},{"title":"DeadDigger","type":0,"sectionRef":"#","url":"/docs/dead-digger","content":"DeadDigger Dead Digger™ 2024.01 Changelog​ Changelog 2024-01-31 Major Rewrite [3.0] Hotspots no longer have to be entered in the script. You can select them from the dropdown listedHotspots are filtered based on your current levelAdded functionality to destroy artifactsAdded functionality to bank artifacts. [Please refer to the Configuration section on how to set this up]After an artifact is found, we instantly start digging againAuto Screener support added - If it is present in inventory, doesn't try to drop soil or fill ore boxType of soil need not be set anymore, it is automatically infered from the hotspot selectedEntities with similar names no longer cause an issue 2023-09-21 Added Functionality [2.0] Overhauled scriptAdded UI (Thanks HigginsHax)Added checking soilbox content through VarbitsAdded Soil droppingAdded simple cart depositing 2023-08-31 Release [1.0] Release Requirements​ Requirements AutoScreener / Soilbox has to be present in inventorySoildbox has to be on the action bar slot with a keybind configuredThe soil for the location you're at should be on the action bar slot with a keybind configuredSteps mentioned in the Configuration section have to be followed for proper functionality of the following Depositing materialsBanking artifacts Configuration​ Configuration The following three methods have to be configured by you based on the digsite. Depositing​ The following function has to be configured based on the excavation site you're at. -- This function handles depositing local function depositCart() API.logDebug('Inventory is full after using soilbox, trying to deposit: ' .. depositAttempt) depositAttempt = depositAttempt + 1; local cart = API.GetAllObjArrayInteract_str({ cartName }, 60, 0) if #cart &gt; 0 then API.DoAction_Object_string1(0x29, API.OFF_ACT_GeneralObject_route0, { cartName }, 60, true); UTILS.randomSleep(800) API.WaitUntilMovingEnds() if not API.InvFull_() then depositAttempt = 0 end else API.logWarn('Didn\\'t find: &quot;' .. cartName .. '&quot; within 60 tiles') end end Banking​ This function handles banking when Bank Artifacts is selected. local function bank() API.logDebug('Going to bank') end Once you're done banking, you'd have to traverse back to the digsite, which is handled by the below function. local function goBack() API.logDebug('Going back to digsite') end Code​ Code local API = require(&quot;api&quot;) local UTILS = require(&quot;utils&quot;) API.SetDrawLogs(true) API.SetDrawTrackedSkills(true) --#region User Inputs local cartName = &quot;Material storage container&quot; -- name of the object to deposit materials --https://learn.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes local soilboxKeybind = 0x6D -- keybind of the soilbox on actionbar local soilKeybind = 0x6B -- keybind of the soil on actionbar local soilboxCapacity = 100 -- capacity of the soilbox. Increase can be purchased --#endregion --#region Imgui Setup local imguiBackground = API.CreateIG_answer() imguiBackground.box_name = &quot;imguiBackground&quot; imguiBackground.box_start = FFPOINT.new(16, 20, 0) imguiBackground.box_size = FFPOINT.new(400, 116, 0) local getTargetBtn = API.CreateIG_answer() getTargetBtn.box_name = &quot;Get&quot; getTargetBtn.box_start = FFPOINT.new(16, 20, 0) getTargetBtn.box_size = FFPOINT.new(50, 30, 0) getTargetBtn.tooltip_text = &quot;Populate hotspots list&quot; local setTargetBtn = API.CreateIG_answer() setTargetBtn.box_name = &quot;Set&quot; setTargetBtn.box_start = FFPOINT.new(60, 20, 0) setTargetBtn.box_size = FFPOINT.new(50, 30, 0) setTargetBtn.tooltip_text = &quot;The script excavate this spot&quot; local imguicombo = API.CreateIG_answer() imguicombo.box_name = &quot;Hotspots &quot; imguicombo.box_start = FFPOINT.new(100, 20, 0) imguicombo.stringsArr = { &quot;a&quot;, &quot;b&quot; } imguicombo.tooltip_text = &quot;Available hotspots to target&quot; local imguiCurrentTarget = API.CreateIG_answer() imguiCurrentTarget.box_name = &quot;Current Target:&quot; imguiCurrentTarget.box_start = FFPOINT.new(30, 50, 0) local imguiExcavate = API.CreateIG_answer() imguiExcavate.box_name = &quot;Excavate&quot; imguiExcavate.box_start = FFPOINT.new(18, 60, 0) imguiExcavate.box_size = FFPOINT.new(80, 30, 0) imguiExcavate.tooltip_text = &quot;Start/Stop Excavating&quot; local imguiTerminate = API.CreateIG_answer() imguiTerminate.box_name = &quot;Stop Script&quot; imguiTerminate.box_start = FFPOINT.new(100, 60, 0) imguiTerminate.box_size = FFPOINT.new(100, 30, 0) imguiTerminate.tooltip_text = &quot;Exit the script&quot; local imguiRuntime = API.CreateIG_answer() imguiRuntime.box_name = &quot;imguiRuntime&quot; imguiRuntime.box_start = FFPOINT.new(30, 90, 0) local imguiDestroy = API.CreateIG_answer() imguiDestroy.box_name = &quot;Destroy Artifacts&quot; imguiDestroy.tooltip_text = &quot;Destroying: false&quot; imguiDestroy.box_start = FFPOINT.new(200, 60, 0) local imguiBank = API.CreateIG_answer() imguiBank.box_name = &quot;Bank Artifacts&quot; imguiBank.tooltip_text = &quot;Banking: false&quot; imguiBank.box_start = FFPOINT.new(200, 80, 0) --#endregion --#region Variables init local targetPlaceholder = &quot;None. Click Set Hotspot&quot; local MAX_IDLE_TIME_MINUTES = 5 local startTime, afk = os.time(), os.time() local depositAttempt = 0 local artifactsFound = 0 local soilBoxFull = false local shouldBank = false local shouldDestroy = false local target = targetPlaceholder local runLoop = false local targetNotFoundCount = 0 local targets = {} local selectedTarget local COLORS = { BACKGROUND = ImColor.new(10, 13, 29), TARGET_UNSET = ImColor.new(189, 185, 167), TARGET_SET = ImColor.new(70, 143, 126), EXCAVATE = ImColor.new(84, 166, 102), PAUSED = ImColor.new(238, 59, 83), RUNTIME = ImColor.new(198, 120, 102) } imguiBackground.colour = COLORS.BACKGROUND imguiCurrentTarget.colour = COLORS.TARGET_UNSET imguiRuntime.colour = COLORS.EXCAVATE --#endregion --#region Util functions local function idleCheck() local timeDiff = os.difftime(os.time(), afk) local randomTime = math.random((MAX_IDLE_TIME_MINUTES * 60) * 0.6, (MAX_IDLE_TIME_MINUTES * 60) * 0.9) if timeDiff &gt; randomTime then API.PIdle2() afk = os.time() end end local function formatElapsedTime(start) local currentTime = os.time() local elapsedTime = currentTime - start local hours = math.floor(elapsedTime / 3600) local minutes = math.floor((elapsedTime % 3600) / 60) local seconds = elapsedTime % 60 return string.format(&quot;Runtime: %02d:%02d:%02d&quot;, hours, minutes, seconds) end local function gameStateChecks() local gameState = API.GetGameState() if (gameState ~= 3) then API.logError('Not ingame with state: ' .. tostring(gameState)) print('Not ingame with state: ' .. tostring(gameState)) API.Write_LoopyLoop(false) return end if targetNotFoundCount &gt; 30 then imguiExcavate.box_name = &quot;Excavate&quot; runLoop = false API.Write_LoopyLoop(false) end end local function terminate() runLoop = false API.Write_LoopyLoop(false) end --#endregion local DIGSITES = { EVERLIGHT = { SOIL = { ID = 49519, VB = 9371 }, PRODROMOI = { LABEL = &quot;Prodromoi remains&quot;, ID = { 116661 }, LEVEL = 42 }, MONOCEROS = { LABEL = &quot;Monoceros remains&quot;, ID = { 116663 }, LEVEL = 48 }, AMPHITHEATER = { LABEL = &quot;Amphitheatre debris&quot;, ID = { 116665 }, LEVEL = 51 }, CERAMICS = { LABEL = &quot;Ceramics studio debris&quot;, ID = { 116666, 116667 }, LEVEL = 56 }, STADIO = { LABEL = &quot;Stadio debris&quot;, ID = { 116669 }, LEVEL = 61 }, DOMINION = { LABEL = &quot;Dominion Games podium&quot;, ID = { 116671 }, LEVEL = 69 }, OIKOS_STUDIO = { LABEL = &quot;Oikos studio debris&quot;, ID = { 116673 }, LEVEL = 72 }, OIKOS_HUT = { LABEL = &quot;Oikos fishing hut remnants&quot;, ID = { 116675 }, LEVEL = 84 }, ACROPOLIS = { LABEL = &quot;Acropolis debris&quot;, ID = { 116677 }, LEVEL = 92 }, ICYENE = { LABEL = &quot;Icyene weapon rack&quot;, ID = { 116679 }, LEVEL = 100 }, STOCKPILED_ART = { LABEL = &quot;Stockpiled art&quot;, ID = { 116683 }, LEVEL = 105 }, BIBLIOTHEKE = { LABEL = &quot;Bibliotheke debris&quot;, ID = { 116680, 116681 }, LEVEL = 109 }, OPTIMATOI = { LABEL = &quot;Optimatoi remains&quot;, ID = { 116685 }, LEVEL = 117 } }, INFERNAL = { SOIL = { ID = 49521, VB = 9372 }, LODGE_BAR = { LABEL = &quot;Lodge bar storage&quot;, ID = { 116817 }, LEVEL = 20 }, LODGE_ART = { LABEL = &quot;Lodge art storage&quot;, ID = { 116819 }, LEVEL = 24 }, CULTIST = { LABEL = &quot;Cultist footlocker&quot;, ID = { 116821 }, LEVEL = 29 }, SACRIFICIAL = { LABEL = &quot;Sacrificial altar&quot;, ID = { 116823 }, LEVEL = 36 }, DIS_DUNGEON = { LABEL = &quot;Dis dungeon debris&quot;, ID = { 116825 }, LEVEL = 45 }, INFERNAL = { LABEL = &quot;Infernal art&quot;, ID = { 116827 }, LEVEL = 65 }, SHAKROTH = { LABEL = &quot;Shakroth remains&quot;, ID = { 116829 }, LEVEL = 68 }, ANIMAL_TROPHIES = { LABEL = &quot;Animal trophies&quot;, ID = { 116831 }, LEVEL = 81 }, DIS_OVERSPILL = { LABEL = &quot;Dis overspill&quot;, ID = { 116833 }, LEVEL = 89 }, BYZROTH = { LABEL = &quot;Byzroth remains&quot;, ID = { 116835 }, LEVEL = 98 }, HELLFIRE_FORGE = { LABEL = &quot;Hellfire forge&quot;, ID = { 116839 }, LEVEL = 104 }, CHTHONIAN = { LABEL = &quot;Chthonian trophies&quot;, ID = { 116837 }, LEVEL = 110 }, TSUTSAROTH = { LABEL = &quot;Tsutsaroth remains&quot;, ID = { 116841 }, LEVEL = 116 } }, KHARID = { SOIL = { ID = 49517, VB = 9370 }, VENATOR = { LABEL = &quot;Venator remains&quot;, ID = { 117101 }, LEVEL = 5 }, LEGIONARY = { LABEL = &quot;Legionary remains&quot;, ID = { 117103 }, LEVEL = 12 }, FORT = { LABEL = &quot;Fort debris&quot;, ID = { 116921, 116922, 116923, 116924 }, LEVEL = 12 }, CASTRA = { LABEL = &quot;Castra debris&quot;, ID = { 117106 }, LEVEL = 12 }, ADMINISTRATUM = { LABEL = &quot;Administratum debris&quot;, ID = { 117108 }, LEVEL = 25 }, PRAESIDIO = { LABEL = &quot;Praesidio remains&quot;, ID = { 117110 }, LEVEL = 47 }, CARCERUM = { LABEL = &quot;Carcerem debris&quot;, ID = { 117112 }, LEVEL = 58 }, CHAPEL = { LABEL = &quot;Kharid-et chapel debris&quot;, ID = { 117114 }, LEVEL = 74 }, PONTIFEX = { LABEL = &quot;Pontifex remains&quot;, ID = { 117116 }, LEVEL = 81 }, ORCUS_ALTAR = { LABEL = &quot;Orcus altar&quot;, ID = { 117118 }, LEVEL = 86 }, ARMARIUM = { LABEL = &quot;Armarium debris&quot;, ID = { 117120 }, LEVEL = 93 }, CULINARUM = { LABEL = &quot;Culinarum debris&quot;, ID = { 117122, 119386 }, LEVEL = 100 }, ANCIENT = { LABEL = &quot;Ancient magick munitions&quot;, ID = { 117124 }, LEVEL = 107 }, PRAETORIAN = { LABEL = &quot;Praetorian remains&quot;, ID = { 117126 }, LEVEL = 114 }, WAR = { LABEL = &quot;War table debris&quot;, ID = { 117128 }, LEVEL = 118 } }, ORTHEN = { SOIL = { ID = 50696, VB = 9578 }, VARANUSAUR = { LABEL = &quot;Varanusaur remains&quot;, ID = { 119075 }, LEVEL = 90 }, RELIQUARY = { LABEL = &quot;Dragonkin reliquary&quot;, ID = { 119077 }, LEVEL = 96 }, COFFIN = { LABEL = &quot;Dragonkin coffin&quot;, ID = { 119079 }, LEVEL = 99 }, AUTOPSY = { LABEL = &quot;Autopsy table&quot;, ID = { 119081 }, LEVEL = 101 }, EXPERIMENT = { LABEL = &quot;Experiment workbench&quot;, ID = { 119083 }, LEVEL = 102 }, AUGHRA = { LABEL = &quot;Aughra remains&quot;, ID = { 119085 }, LEVEL = 106 }, MOKSHA = { LABEL = &quot;Moksha device&quot;, ID = { 119087 }, LEVEL = 108 }, MINE = { LABEL = &quot;Xolo mine&quot;, ID = { 119089 }, LEVEL = 113 }, REMAINS = { LABEL = &quot;Xolo remains&quot;, ID = { 119091 }, LEVEL = 119 }, SAURTHEN = { LABEL = &quot;Saurthen debris&quot;, ID = { 119093 }, LEVEL = 120 } }, SENNTISTEN = { SOIL = { ID = 49517, VB = 9370 }, MINISTRY = { LABEL = &quot;Ministry remains&quot;, ID = { 121157 }, LEVEL = 60 }, CATHEDRAL = { LABEL = &quot;Cathedral debris&quot;, ID = { 121155 }, LEVEL = 62 }, MARKETPLACE = { LABEL = &quot;Marketplace debris&quot;, ID = { 121159 }, LEVEL = 63 }, INQUISITOR = { LABEL = &quot;Inquisitor remains&quot;, ID = { 121161 }, LEVEL = 64 }, GLADIATOR = { LABEL = &quot;Gladiator remains&quot;, ID = { 121165 }, LEVEL = 66 }, CITIZEN = { LABEL = &quot;Citizen remains&quot;, ID = { 121163 }, LEVEL = 67 } }, STORMGUARD = { SOIL = { ID = 49523, VB = 9373 }, IKOVIAN = { LABEL = &quot;Ikovian memorial&quot;, ID = { 117202 }, LEVEL = 70 }, KESHIK = { LABEL = &quot;Keshik ger&quot;, ID = { 117204 }, LEVEL = 76 }, TAILORY = { LABEL = &quot;Tailory debris&quot;, ID = { 117206 }, LEVEL = 81 }, WEAPONS = { LABEL = &quot;Weapons research debris&quot;, ID = { 117208 }, LEVEL = 85 }, GRAVITRON = { LABEL = &quot;Gravitron research debris&quot;, ID = { 117210 }, LEVEL = 91 }, TOWER = { LABEL = &quot;Keshik tower debris&quot;, ID = { 117214 }, LEVEL = 95 }, GOLEM = { LABEL = &quot;Destroyed golem&quot;, ID = { 117216 }, LEVEL = 98 }, RACK = { LABEL = &quot;Keshik weapon rack&quot;, ID = { 117218 }, LEVEL = 103 }, FLIGHT = { LABEL = &quot;Flight research debris&quot;, ID = { 117212 }, LEVEL = 111 }, AETHERIUM = { LABEL = &quot;Aetherium forge&quot;, ID = { 117220 }, LEVEL = 112 }, HOWL = { LABEL = &quot;Howls workshop debris&quot;, ID = { 117222 }, LEVEL = 118 } }, WARFORGE = { SOIL = { ID = 49525, VB = 9374 }, GLADIATORIAL = { LABEL = &quot;Gladiatorial goblin remains&quot;, ID = { 117365 }, LEVEL = 76 }, CRUCIBLE = { LABEL = &quot;Crucible stands debris&quot;, ID = { 117367 }, LEVEL = 81 }, DORM = { LABEL = &quot;Goblin dorm debris&quot;, ID = { 117371 }, LEVEL = 83 }, BARRICADE = { LABEL = &quot;Barricade&quot;, ID = { 117246, 117247 }, LEVEL = 83 }, WAR_GOD = { LABEL = &quot;Big High War God shrine&quot;, ID = { 117377 }, LEVEL = 89 }, YUBIUSK = { LABEL = &quot;Yubiusk animal pen&quot;, ID = { 117373 }, LEVEL = 94 }, GOBLIN = { LABEL = &quot;Goblin trainee remains&quot;, ID = { 117379 }, LEVEL = 97 }, KYJAZ = { LABEL = &quot;Kyzaj champions boudoir&quot;, ID = { 117375 }, LEVEL = 100 }, SCRAP = { LABEL = &quot;Warforge scrap pile&quot;, ID = { 117381 }, LEVEL = 104 }, RACK = { LABEL = &quot;Warforge weapon rack&quot;, ID = { 117383 }, LEVEL = 110 }, BANDOS = { LABEL = &quot;Bandos sanctum debris&quot;, ID = { 117369 }, LEVEL = 115 }, PIE = { LABEL = &quot;Makeshift pie oven&quot;, ID = { 117385 }, LEVEL = 119 } } } local IDS = { SOILBOX = 49538, AUTOSCREENER = 50161 } local function filterDigsitesByLevel(digsites, level) local filteredDigsites = {} for zone, locations in pairs(digsites) do filteredDigsites[zone] = {} for location, data in pairs(locations) do if type(data) == &quot;table&quot; and data.LEVEL and data.LEVEL &lt;= level then table.insert(filteredDigsites[zone], { [location] = data }) end end table.sort(filteredDigsites[zone], function(a, b) return a[next(a)].LEVEL &gt; b[next(b)].LEVEL end) end return filteredDigsites end -- Function to filter DIGSITES by IDs local function filterDigsitesByIds(digsites, idsToFilter) local filteredDigsites = {} for zone, locations in pairs(digsites) do filteredDigsites[zone] = {} for location, data in pairs(locations) do if type(data) == &quot;table&quot; and data.VB then -- ignore soil table elseif type(data) == &quot;table&quot; and data.ID then local filteredIdTable = {} for _, id in ipairs(data.ID) do if UTILS.tableIncludes(idsToFilter, id) then table.insert(filteredIdTable, id) end end if #filteredIdTable &gt; 0 then local filteredData = { LABEL = data.LABEL, ID = filteredIdTable, LEVEL = data.LEVEL } table.insert(filteredDigsites[zone], { [location] = filteredData }) end end end table.sort(filteredDigsites[zone], function(a, b) return a[next(a)].LEVEL &gt; b[next(b)].LEVEL end) end return filteredDigsites end local function getFilteredItemIds(filteredDigsites) local ids = {} for _, locations in pairs(filteredDigsites) do for _, locationData in ipairs(locations) do for _, data in pairs(locationData) do for _, id in ipairs(data.ID) do table.insert(ids, id) end end end end return ids end local function populateDropdown() local filteredHotspots = filterDigsitesByLevel(DIGSITES, API.GetSkillByName(&quot;ARCHAEOLOGY&quot;).level) -- Get the IDs of the filtered and sorted items local items = {} local filteredItemIds = getFilteredItemIds(filteredHotspots) local found = API.GetAllObjArrayInteract(filteredItemIds, 70, 0) local distinct = UTILS.getDistinctByProperty(found, 'Id') for i = 1, #distinct, 1 do local item = distinct[i] table.insert(items, (item.Id)) end local foundThingsByLevel = filterDigsitesByIds(DIGSITES, items) for zone, locations in pairs(foundThingsByLevel) do for _, locationData in ipairs(locations) do for location, data in pairs(locationData) do table.insert(targets, { SOIL = DIGSITES[zone].SOIL, LABEL = &quot;Lvl:&quot; .. data.LEVEL .. &quot; - &quot; .. data.LABEL, IDS = data.ID }) end end end if #targets &gt; 0 then local valueStrings = {} for i = 1, #targets, 1 do local item = targets[i] table.insert(valueStrings, item.LABEL) end imguicombo.stringsArr = valueStrings imguicombo.int_value = 0 else API.logWarn('No hotspots found in range') end -- return dropdownValues end local function setHotspot() API.logDebug('setHotspot') local currentHotspot = target local selected = imguicombo.stringsArr[imguicombo.int_value + 1] selectedTarget = targets[imguicombo.int_value + 1] if currentHotspot ~= selected then target = selected end imguiCurrentTarget.colour = COLORS.TARGET_SET setTargetBtn.return_click = false end local function pauseExcavation() runLoop = false API.logDebug(&quot;Excavation paused&quot;) imguiExcavate.return_click = false imguiCurrentTarget.colour = COLORS.PAUSED imguiRuntime.colour = COLORS.PAUSED imguiExcavate.box_name = &quot;Excavate&quot; end local function startExcavation() API.logDebug(&quot;Excavation started&quot;) runLoop = true imguiCurrentTarget.colour = COLORS.EXCAVATE imguiRuntime.colour = COLORS.EXCAVATE imguiExcavate.box_name = &quot;Pause&quot; end local artifactFoundInterface = { InterfaceComp5.new(1189, 2, -1, -1, 0), } local destroyInterface = { InterfaceComp5.new(1183, 11, -1, -1, 0), } local function destroyInterfaceFound() local result = API.ScanForInterfaceTest2Get(true, destroyInterface) if #result &gt; 0 then return true else return false end end local function artifactFoundInterfacePresent() local result = API.ScanForInterfaceTest2Get(true, artifactFoundInterface) if #result &gt; 0 then return true else return false end end local function FindHl(objects, maxdistance, highlight) local objObjs = API.GetAllObjArray1(objects, maxdistance, 0) local hlObjs = API.GetAllObjArray1(highlight, maxdistance, 4) local shiny = {} for i = 0, 2.9, 0.1 do for _, obj in ipairs(objObjs) do for _, hl in ipairs(hlObjs) do if math.abs(obj.Tile_XYZ.x - hl.Tile_XYZ.x) &lt; i and math.abs(obj.Tile_XYZ.y - hl.Tile_XYZ.y) &lt; i then shiny = obj end end end end return shiny end local function depositCart() API.logDebug('Inventory is full after using soilbox, trying to deposit: ' .. depositAttempt) depositAttempt = depositAttempt + 1; local cart = API.GetAllObjArrayInteract_str({ cartName }, 60, 0) if #cart &gt; 0 then API.DoAction_Object_string1(0x29, API.OFF_ACT_GeneralObject_route0, { cartName }, 60, true); UTILS.randomSleep(800) API.WaitUntilMovingEnds() if not API.InvFull_() then depositAttempt = 0 end else API.logWarn('Didn\\'t find: &quot;' .. cartName .. '&quot; within 60 tiles') end end local function destroyArtifacts() API.logWarn('destroy') local inventory = API.ReadInvArrays33() local items = UTILS.getDistinctByProperty(inventory, 'textitem') for i = 1, #items, 1 do local item = items[i] if string.find(tostring(item.textitem), 'damaged') then local count = API.InvItemcount_1(item.itemid1) API.logWarn('Destroying ' .. item.textitem) -- API.DoAction_Inventory1(item.itemid1,0,3, API.OFF_ACT_GeneralInterface_route2) API.DoAction_Interface(0x24,item.itemid1,8,item.id1,item.id2,item.id3,API.OFF_ACT_GeneralInterface_route2) -- API.DoAction_Interface(0x24, item.itemid1, 8, 1473, 5, i - 1, API.OFF_ACT_GeneralInterface_route2) UTILS.SleepUntil(destroyInterfaceFound,5,'Destroying ' .. item.textitem) if count &gt; 1 then API.DoAction_Interface(0xffffffff,0xffffffff,0,1183,7,-1,API.OFF_ACT_GeneralInterface_Choose_option) else API.DoAction_Interface(0xffffffff,0xffffffff,0,1183,5,-1,API.OFF_ACT_GeneralInterface_Choose_option) end UTILS.randomSleep(800) end end end local function dropSoil() if soilBoxFull then local soilCount = API.InvItemcount_1(selectedTarget.SOIL.ID) if soilCount &gt; 0 then API.logDebug('Dropping ' .. soilCount .. &quot; soil&quot;) for i = 1, soilCount, 1 do API.KeyboardPress2(soilKeybind, 100, 200) UTILS.rangeSleep(50, 10, 100) end end end UTILS.randomSleep(800) end local function bank() API.logDebug('Going to bank') API.DoAction_Object_string1(0x5, 80, { &quot;Bank chest&quot; }, 50, false) UTILS.randomSleep(600 * 2) API.WaitUntilMovingEnds() if API.BankOpen2() then API.KeyboardPress2(0x31, 100, 200) end end local function goBack() API.logDebug('Going back to digsite') end local function fillSoilbox() if API.InvItemFound1(IDS.AUTOSCREENER) then return end if API.InvItemFound1(IDS.SOILBOX) then if API.VB_FindPSett(selectedTarget.SOIL.VB).SumOfstate == soilboxCapacity then soilBoxFull = true else soilBoxFull = false API.logDebug('Inventory is full, trying to fill soilbox') API.KeyboardPress2(soilboxKeybind, 100, 200) UTILS.randomSleep(600) end end end local function inventoryCheck() if depositAttempt &gt; 5 then API.logError('Inventory still full after depositing 5 times') runLoop = false pauseExcavation() return false end if API.InvFull_() then local emptySpots = API.Invfreecount_() fillSoilbox() if shouldDestroy then destroyArtifacts() end local spotsAfterFill = API.Invfreecount_() if spotsAfterFill &lt;= emptySpots then depositCart() if shouldBank then bank() goBack() end end end end local function followTimeSprite(objects) local foundObjects = API.GetAllObjArray1(objects.IDS, 60, 0) local targetIds = {} for i = 1, #foundObjects do local rock = foundObjects[i] table.insert(targetIds, rock.Id) end local sprite = FindHl(targetIds, 60, { 7307 }) if not API.ReadPlayerMovin2() then if sprite.Id ~= nil then local spritePos = WPOINT.new(sprite.TileX / 512, sprite.TileY / 512, sprite.TileZ / 512) local distanceF = API.Math_DistanceF(API.PlayerCoordfloat(), sprite.Tile_XYZ) if distanceF &gt; 2 then UTILS.randomSleep(200) if not API.CheckAnim(20) then API.logInfo(&quot;Excavating &quot; .. target) else API.logInfo(&quot;Sprite has moved, chasing it&quot;) end API.DoAction_Object2(0x2, API.OFF_ACT_GeneralObject_route0, { sprite.Id }, 60, spritePos) UTILS.randomSleep(1000) API.WaitUntilMovingEnds() return end end if artifactFoundInterfacePresent() then artifactsFound = artifactsFound + 1 API.logInfo(&quot;Found artifact, excavating again &quot; .. target) API.DoAction_Object1(0x2, API.OFF_ACT_GeneralObject_route0, targetIds, 60) UTILS.randomSleep(800) return end if not API.CheckAnim(40) and not API.InvFull_() then API.logInfo(&quot;Excavating &quot; .. target) API.DoAction_Object1(0x2, API.OFF_ACT_GeneralObject_route0, targetIds, 60) UTILS.randomSleep(800) end end end local function drawGUI() if imguiTerminate.return_click then terminate() end if imguiExcavate.return_click then if not runLoop then startExcavation() end else if runLoop then pauseExcavation() end end if getTargetBtn.return_click then populateDropdown() getTargetBtn.return_click = false end if not runLoop and setTargetBtn.return_click then setHotspot() end local destroyStatus = imguiDestroy.box_ticked local bankStatus = imguiBank.box_ticked if destroyStatus ~= shouldDestroy then shouldDestroy = destroyStatus API.logWarn('Destroying artifacts? : ' .. tostring(shouldDestroy)) imguiDestroy.tooltip_text = &quot;Destroying: &quot; .. tostring(shouldDestroy) end if bankStatus ~= shouldBank then shouldBank = bankStatus API.logWarn('Banking artifacts? : ' .. tostring(shouldBank)) imguiBank.tooltip_text = &quot;Banking: &quot; .. tostring(shouldBank) end API.DrawSquareFilled(imguiBackground) API.DrawBox(setTargetBtn) API.DrawBox(getTargetBtn) API.DrawCheckbox(imguiDestroy) API.DrawCheckbox(imguiBank) if (#targets &gt; 0) then API.DrawComboBox(imguicombo, false) end imguiCurrentTarget.string_value = &quot;Current hotspot:&quot; .. target if runLoop then imguiRuntime.string_value = formatElapsedTime(startTime) --os.difftime(os.time(),startTime) end API.DrawBox(imguiExcavate) API.DrawBox(imguiTerminate) API.DrawTextAt(imguiCurrentTarget) API.DrawTextAt(imguiRuntime) end --#endregion --#region Main loop API.Write_LoopyLoop(true) populateDropdown() while (API.Read_LoopyLoop()) do ------------------------------------------------------ API.DoRandomEvents() gameStateChecks() idleCheck() drawGUI() if runLoop and selectedTarget ~= nil then inventoryCheck() dropSoil() followTimeSprite(selectedTarget) end UTILS.randomSleep(300) end ---------------------------------------------------------------------------------- --#endregion Credits​ Credits HigginsHax​ Contribution - ProgressBar to track XP and runtime Grunstadt​ Contribution - Soilbox varbits","keywords":"","version":"Next"},{"title":"DeadUtils","type":0,"sectionRef":"#","url":"/docs/dead-utils","content":"DeadUtils Dead Utils™ 2024.01 Usage​ Usage local UTILS = require(&quot;utils&quot;) UTILS:antiIdle() Changelog​ Changelog 2024-01-31 Reworked [2.0] Added UTILS:antiIdle()Added UTILS.gameStateChecks()Added UTILS.CanUseLodestone()Added UTILS.getDistinctByProperty()Added UTILS.LoadActionBar()Added UTILS.getSkillOnBar()Added UTILS.countTicks()Added UTILS.rangeSleep()Added UTILS.SleepUntil()Added UTILS.SleepUtilWithoutChecks()Added UTILS.getAmountInOrebox() 2024-01-20 Release [1.0] Release Functions​ Functions antiIdle​ The anti idle function we've all been using isEmpty​ Parameters s string Function to tell if a string is empty randomSleep​ Parameters milliseconds number Sleeps to a random duration gameStateChecks​ Checks for the following If we're logged inIf script is looping CanUseLodestone​ Checks if we can use a lodestone After exiting combat, you can use a lodestone for a specific duration. This method tells you when you can use a lodestone waitForPlayerAtCoords​ Parameters coords WPOINTthreshold numbermaxWaitInSeconds number Wait for a player to reach a coords within a threshold, upto defined seconds concatenateTables​ Parameters comma seperated list of tables to concatenate Returns a new table combining all the input tables Example local ITEMS = {} ITEMS.COMMON = { 995 -- gold coins } ITEMS.RUNES = { 554, -- fire 555, -- water 556, -- air 557 -- earth } local lootableItems = UTILS.concatenateTables(ITEMS.COMMON, ITEMS.RUNES) getDistinctValues​ Parameters inputTable table Returns a table with unique values getDistinctByProperty​ Parameters inputTable tableproperty string Returns a table with unique elements based on the provided property DO_RandomEvents​ Handles the following random events 18204 Chronicle fragment, 18205 other peoples19884 Guthix butterfly26022 Seren spirit27228 Divine blessing27297 Forge phoenix28411 Catalyst30599 Halloween Pumpkin15451 Fire spirit LoadActionBar​ Parameters barNumber number Loads the primary action bar getSkillOnBar​ Parameters skillName stringGet's a skill on the ability bar Checks if it can be used Returns nil if the skill isn't found or can't be used countTicks​ Parameters ticks number Sleeps for the given number of game ticks rangeSleep​ Parameters milliseconds numberrandMin number = 0randMax number = 0 Sleeps for random number of milliseconds SleepUntil​ Parameters conditionFunc functiontimeout number (seconds)message string... any arguments to the function@return boolean Sleeps until the passed condition returns true or the timeout duration is reached Checks for random events, game state and API.Read_LoopyLoop while sleeping Example function UTILS.isChooseOptionInterfaceOpen() return API.Compare2874Status(12, false) end local function waitForChooseOption() return UTILS.SleepUntil(UTILS.isChooseOptionInterfaceOpen, 20, &quot;Waiting for choose option to open&quot;) end local wasItOpen = waitForChooseOption() SleepUtilWithoutChecks​ Parameters conditionFunc functiontimeout number (seconds)message string... any arguments to the function@return boolean Sleeps until the passed condition returns true or the timeout duration is reached There are no checks in place getAmountInOrebox​ Parameters oreId number Returns the number of ores of requested id present in ore box. UTILS.ORES.NECRITE can be used in place of the ID for Necrite (44826) Code​ Code --[[ #Script Name: &lt;utils.lua&gt; # Description: &lt;Collection of utility functions&gt; # Autor: &lt;Dead (dea.d - Discord)&gt; # Version: &lt;2.0&gt; # Datum: &lt;2024.01.31&gt; --]] local API = require(&quot;api&quot;) local UTILS = {} UTILS.__index = UTILS function UTILS.new() local self = setmetatable({}, UTILS) self.afk = os.time() self.randomTime = math.random(180, 280) self.worldTime = os.time() return self end local MAX_IDLE_TIME_MINUTES = 5 UTILS.ORES = { COPPER = 436, TIN = 438, IRON = 440, SILVER = 442, GOLD = 444, MITHRIL = 447, ADAMANTITE = 449, RUNITE = 451, COAL = 453, BANITE = 21778, LUMINITE = 44820, ORICHALCITE = 44822, DRAKOLITH = 44824, NECRITE = 44826, PHASMATITE = 44828, LIGHT_ANIMICA = 44830, DARK_ANIMICA = 44832 } --- The anti idle function we've all been using ---@return boolean function UTILS:antiIdle() local timeDiff = os.difftime(os.time(), self.afk) local randomTime = math.random((MAX_IDLE_TIME_MINUTES * 60) * 0.6, (MAX_IDLE_TIME_MINUTES * 60) * 0.9) if timeDiff &gt; randomTime then API.PIdle2() self.afk = os.time() return true end end --- Function to tell if a string is empty function UTILS.isEmpty(s) return s == nil or s == '' end --- Function to convert userdata to vector&lt;string&gt; function UTILS.UserDataToVector(userdata) local vector = {} -- Iterate over the userdata values and extract them for i = 1, #userdata do vector[i] = userdata[i] end return vector end --- Function to sleep for milliseconds with a random delay ---@param milliseconds number function UTILS.randomSleep(milliseconds) local randomDelay = math.random(1, 200) local totalDelay = milliseconds + randomDelay local start = os.clock() local target = start + (totalDelay / 1000) while os.clock() &lt; target do API.RandomSleep2(100, 0, 0) end end --- Function to convert userdata to string function UTILS.UserDataToString(userdata) local vector = {} -- Iterate over the userdata values and extract them for i = 1, #userdata do vector[i] = userdata[i] end return table.concat(vector, &quot;&quot;) end --- Function to convert a Lua table to string ---comment ---@param tbl table ---@return string function UTILS.tableToString(tbl) local strTable = {} for _, innerTbl in ipairs(tbl) do local strInnerTable = {} for _, value in ipairs(innerTbl) do table.insert(strInnerTable, tostring(value)) end table.insert(strTable, &quot;{&quot; .. table.concat(strInnerTable, &quot;, &quot;) .. &quot;}&quot;) end return table.concat(strTable, &quot;, &quot;) end --- Function to check for various game states&lt;br&gt; --- Checks if we're logged in and if API.Read_LoopyLoop() is true ---@return boolean function UTILS.gameStateChecks() if not API.PlayerLoggedIn() then print('not logged in') API.Write_LoopyLoop(false) return false end if not API.Read_LoopyLoop() then print('LoopyLoop is false') return false end return true end --- Function to wait for an animation to complete, upto defined seconds ---@param animationId number ---@param maxWaitInSeconds number ---@return boolean function UTILS.waitForAnimation(animationId, maxWaitInSeconds) local animation = animationId or 0 local waitTime = maxWaitInSeconds or 5 local exitLoop = false local start = os.time() while not exitLoop and os.time() - start &lt; waitTime do if not (API.Read_LoopyLoop() or API.PlayerLoggedIn()) then exitLoop = true return false end if (API.ReadPlayerAnim() == animation) then exitLoop = true return true end UTILS.rangeSleep(50, 50, 50) end end --- After exiting combat, you can use a lodestone for a specific duration.&lt;br&gt; --- This method tells you when you can use a lodestone ---@return boolean function UTILS.CanUseLodestone() local vb = API.VB_FindPSett(7994) return vb.state == -1 or vb.stateAlt == -1 end --- Function to wait for a player to reach a coords within a threshold, upto defined seconds ---comment ---@param coords WPOINT ---@param threshold number ---@param maxWaitInSeconds number ---@return boolean function UTILS.waitForPlayerAtCoords(coords, threshold, maxWaitInSeconds) local waitTime = maxWaitInSeconds or 5 local variance = threshold or 0 local exitLoop = false local start = os.time() while not exitLoop and os.time() - start &lt; waitTime do if not (API.Read_LoopyLoop() or API.PlayerLoggedIn()) then exitLoop = true return false end if (API.PInAreaW(coords, variance)) then exitLoop = true return true end UTILS.rangeSleep(50, 50, 50) end return false end --- Function to get the label of the table element ---comment ---@param arg any ---@param table table ---@return any | nil function UTILS.GetLabelFromArgument(arg, table) for label, record in pairs(table) do if record == arg then return label end end return nil end --- Function to concatenate tables ---@param ... table[] ---@return table function UTILS.concatenateTables(...) local result = {} for _, tbl in ipairs({ ... }) do for _, value in ipairs(tbl) do table.insert(result, value) end end return result end --- Function to extract distinct values from a table ---@param inputTable table ---@return table function UTILS.getDistinctValues(inputTable) local distinctValues = {} local seenValues = {} for _, value in ipairs(inputTable) do if not seenValues[value] then table.insert(distinctValues, value) seenValues[value] = true end end return distinctValues end --- Function to get you distinct values from the input table based on the property ---comment ---@param inputTable table ---@param property string ---@return table function UTILS.getDistinctByProperty(inputTable, property) local distinctValues = {} local seenValues = {} for _, value in ipairs(inputTable) do local prop = value[property] if not seenValues[prop] then table.insert(distinctValues, value) seenValues[prop] = true end end return distinctValues end --[[ Handles the below random events &lt;br&gt;18204 Chronicle fragment, other peopls 18205 &lt;br&gt;19884 Guthix butterfly &lt;br&gt;26022 Seren spirit &lt;br&gt;27228 Divine blessing &lt;br&gt;27297 Forge phoenix &lt;br&gt;28411 Catalyst &lt;br&gt;30599 Halloween Pumpkin &lt;br&gt;15451 Fire spirit ]] ---@return boolean function UTILS.DO_RandomEvents() local F_obj = API.GetAllObjArrayInteract({ 19884, 26022, 27228, 27297, 28411, 30599, 15451 }, 20, 1) --if not (F_obj) == nil then if (F_Obj) ~= nil then print(&quot;Random event object detected: trying to click&quot;) UTILS.randomSleep(1000) if API.DoAction_NPC__Direct(0x29, API.InteractNPC_route, F_obj[1]) then UTILS.randomSleep(1000) return true end end return false end --- Function to load a primary action bar ---@param barNumber number ---@return boolean function UTILS.LoadActionBar(barNumber) print(&quot;Loading action bar: &quot; .. barNumber) local selected = { id = nil, number = nil, offset = nil } -- Set [5th param in DO::DoAction_Interface] if barNumber &gt;= 1 and barNumber &lt;= 10 then selected.number = 255 elseif barNumber &gt;= 11 and barNumber &lt;= 15 then selected.number = 254 elseif barNumber &gt;= 16 and barNumber &lt;= 18 then selected.number = 253 else print(&quot;Invalid bar number passed: &quot; .. tostring(barNumber)) return false end -- Set Offset [7th param in DO::DoAction_Interface] if barNumber &gt;= 1 and barNumber &lt;= 5 then selected.offset = API.OFF_ACT_GeneralInterface_route elseif barNumber &gt;= 6 and barNumber &lt;= 18 then selected.offset = API.OFF_ACT_GeneralInterface_route2 end -- set number [3rd param in DO::DoAction_Interface] if barNumber == 10 or barNumber == 15 then selected.id = 10 elseif barNumber &gt;= 1 and barNumber &lt;= 9 then selected.id = barNumber elseif barNumber &gt;= 11 and barNumber &lt;= 14 then selected.id = barNumber - 5 elseif barNumber &gt;= 16 and barNumber &lt;= 18 then selected.id = barNumber - 10 end -- print(&quot;selected is: {id: &quot; .. selected.id .. &quot;, number: &quot; .. selected.number .. &quot;, offset: &quot; .. selected.offset) API.DoAction_Interface(0xffffffff, 0xffffffff, selected.id, 1430, selected.number, -1, selected.offset) end --- Get's a skill on the ability bar&lt;br&gt; --- Checks if it can be used&lt;br&gt; --- Returns nil if the skill isn't found or can't be used ---@param skillName string ---@return Abilitybar | nil function UTILS.getSkillOnBar(skillName) local skillOnAB = API.GetABs_name1(skillName) if skillOnAB.id ~= 0 and skillOnAB.enabled then return skillOnAB else return nil end end --- Waits for a number of ticks ---@param ticks number ---@return boolean function UTILS.countTicks(ticks) local ticker = 0 API.Check_tick() while ticker &lt; ticks do UTILS.rangeSleep(10, 10, 10) if API.Check_tick() then ticker = ticker + 1 end if not UTILS.gameStateChecks() then return false end end return true end -- Function to sleep for milliseconds with a random delay ---comment ---@param milliseconds number ---@param randMin number = 0 ---@param randMax number = 0 function UTILS.rangeSleep(milliseconds, randMin, randMax) randMin = randMin or 0 randMax = randMax or 0 local randomDelay = math.random(randMin, randMax) local totalDelay = milliseconds + randomDelay local start = os.clock() local target = start + (totalDelay / 1000) while os.clock() &lt; target do API.RandomSleep2(50,0,0) end end --- Sleeps until the condition function returns true&lt;br&gt; --- Checks for other random events,game state and API.Read_LoopyLoop ---@param conditionFunc function ---@param timeout number ---@param message string ---@param ... any ---@return boolean function UTILS.SleepUntil(conditionFunc, timeout, message, ...) local startTime = os.time() local sleepSuccessful = false while not conditionFunc(...) do API.DoRandomEvents() if os.difftime(os.time(), startTime) &gt;= timeout then print(&quot;Stopped waiting for &quot; .. message .. &quot; after &quot; .. timeout .. &quot; seconds.&quot;) break end if not API.Read_LoopyLoop() then print(&quot;Script exited - breaking sleep.&quot;) break end if not UTILS.gameStateChecks() then print(&quot;State checks failed - breaking sleep.&quot;) break end API.RandomSleep2(100, 100, 100) end if conditionFunc(...) then print(&quot;Sleep condition met for &quot; .. message) sleepSuccessful = true end return sleepSuccessful end --- Sleeps until the condition function returns true&lt;br&gt; --- No checks ---@param conditionFunc function ---@param timeout number ---@param message string ---@param ... any ---@return boolean function UTILS.SleepUtilWithoutChecks(conditionFunc, timeout, message, ...) local startTime = os.time() local sleepSuccessful = false while not conditionFunc(...) do API.DoRandomEvents() if os.difftime(os.time(), startTime) &gt;= timeout then print(&quot;Stopped waiting for &quot; .. message .. &quot; after &quot; .. timeout .. &quot; seconds.&quot;) break end API.RandomSleep2(100, 100, 100) end if conditionFunc(...) then print(&quot;Sleep condition met for &quot; .. message) sleepSuccessful = true end return sleepSuccessful end function UTILS.isWorldSelectionOpen() return API.Compare2874Status(61, false) end function UTILS.isCraftingInterfaceOpen() return API.Compare2874Status(40, false) end function UTILS.isChooseOptionInterfaceOpen() return API.Compare2874Status(12, false) end function UTILS.isCookingInterfaceOpen() return API.Compare2874Status(18, false) end function UTILS.isSmeltingInterfaceOpen() return API.Compare2874Status(85, false) end function UTILS.isTeleportSeedInterfaceOpen() return API.Compare2874Status(13, false) end function UTILS.isAuraActive() return API.VB_FindPSett(7702).state &gt; 0 end ---Get number of ores in ore box ---@param oreId integer ---@return integer --[[ Ore IDs: 436 Copper 438 Tin 440 Iron 442 Silver 444 Gold 447 Mithril 449 Adamantite 451 Runite 453 Coal 21778 Banite 44820 Luminite 44822 Orichalcite 44824 Drakolith 44826 Necrite 44828 Phasmatite 44830 Light animica 44832 Dark animica ]] function UTILS.getAmountInOrebox(oreId) local state if oreId == 436 then -- Copper ore state = API.VB_FindPSett(8309).state elseif oreId == 438 then -- Tin ore state = API.VB_FindPSett(8310).state elseif oreId == 440 then -- Iron ore state = API.VB_FindPSett(8311).state elseif oreId == 442 then -- Silver ore state = API.VB_FindPSett(8313).state elseif oreId == 444 then -- Gold ore state = API.VB_FindPSett(8317).state elseif oreId == 447 then -- Mithril ore state = API.VB_FindPSett(8314).state elseif oreId == 449 then -- Adamantite ore state = API.VB_FindPSett(8315).state elseif oreId == 451 then -- Runite ore state = API.VB_FindPSett(8318).state elseif oreId == 453 then -- Coal state = API.VB_FindPSett(8312).state elseif oreId == 21778 then -- Banite ore state = API.VB_FindPSett(8323).state elseif oreId == 44820 then -- Luminite state = API.VB_FindPSett(8316).state elseif oreId == 44822 then -- Orichalcite ore state = API.VB_FindPSett(8319).state elseif oreId == 44824 then -- Drakolith state = API.VB_FindPSett(8320).state elseif oreId == 44826 then -- Necrite ore state = API.VB_FindPSett(8321).state elseif oreId == 44828 then -- Phasmatite state = API.VB_FindPSett(8322).state elseif oreId == 44830 then -- Light animica state = API.VB_FindPSett(8324).state elseif oreId == 44832 then -- Dark animica state = API.VB_FindPSett(8325).state else return -1 end return state &gt;&gt; 0 &amp; 0x3fff end local instance = UTILS.new() return instance ","keywords":"","version":"Next"},{"title":"Lodestones","type":0,"sectionRef":"#","url":"/docs/lodestones","content":"Lodestones Lodestones™ 2024.01 Usage​ Usage local LODESTONES = require(&quot;lodestones&quot;) LODESTONES.Lumbridge() Changelog​ Changelog 2023-11-10 1.1 Added Um 2023-08-09 Release [1.0] Release Code​ Code --[[ #Script Name: &lt;lodestones.lua&gt; # Description: &lt;Functions to teleport to Lodestones&gt; # Autor: &lt;Dead (dea.d - Discord)&gt; # Version: &lt;1.1&gt; # Datum: &lt;2024.02.01&gt; --]] local API = require(&quot;api&quot;) local UTILS = require(&quot;utils&quot;) local LODESTONES = {} LODESTONES.LODESTONE = { AL_KHARID = { id = 11, loc = WPOINT.new(3297, 3184, 0) }, ANACHRONIA = { id = 25, loc = WPOINT.new(5431, 2338, 0) }, ARDOUGNE = { id = 12, loc = WPOINT.new(2634, 3348, 0) }, ASHDALE = { id = 34, loc = WPOINT.new(2474, 2708, 2) }, BANDIT_CAMP = { id = 9, loc = WPOINT.new(2899, 3544, 0) }, BURTHOPE = { id = 13, loc = WPOINT.new(2899, 3544, 0) }, CANIFIS = { id = 27, loc = WPOINT.new(3517, 3515, 0) }, CATHERBY = { id = 14, loc = WPOINT.new(2811, 3449, 0) }, DRAYNOR_VILLAGE = { id = 15, loc = WPOINT.new(3105, 3298, 0) }, EAGLES_PEAK = { id = 28, loc = WPOINT.new(2366, 3479, 0) }, EDGEVILLE = { id = 16, loc = WPOINT.new(3067, 3505, 0) }, FALADOR = { id = 17, loc = WPOINT.new(2967, 3403, 0) }, FORT_FORINTHRY = { id = 23, loc = WPOINT.new(3298, 3525, 0) }, FREMENNIK_PROVINCE = { id = 29, loc = WPOINT.new(2712, 3677, 0) }, KARAMJA = { id = 30, loc = WPOINT.new(2761, 3147, 0) }, LUNAR_ISLE = { id = 10, loc = WPOINT.new(2085, 3914, 0) }, LUMBRIDGE = { id = 18, loc = WPOINT.new(3233, 3221, 0) }, MENAPHOS = { id = 24, loc = WPOINT.new(3216, 2716, 0) }, OOGLOG = { id = 31, loc = WPOINT.new(2532, 2871, 0) }, PORT_SARIM = { id = 19, loc = WPOINT.new(3011, 3215, 0) }, PRIFDDINAS = { id = 35, loc = WPOINT.new(2208, 3360, 1) }, SEERS_VILLAGE = { id = 20, loc = WPOINT.new(2689, 3482, 0) }, TAVERLEY = { id = 21, loc = WPOINT.new(2878, 3442, 0) }, TIRANNWN = { id = 32, loc = WPOINT.new(2254, 3149, 0) }, UM = { id = 36, loc = WPOINT.new(1084, 1768, 1) }, VARROCK = { id = 22, loc = WPOINT.new(3214, 3376, 0) }, WILDERNESS = { id = 33, loc = WPOINT.new(0, 0, 0) }, YANILLE = { id = 26, loc = WPOINT.new(2606, 3093, 0) } } function GoToLodestone(lode) print('Teleporting to ', UTILS.GetLabelFromArgument(lode, LODESTONES.LODESTONE)) LODESTONES.openLodestonesInterface() API.DoAction_Interface(0xffffffff, 0xffffffff, 1, 1092, lode.id, -1, API.OFF_ACT_GeneralInterface_route) API.RandomSleep2(3000, 2050, 5000) print('sleep done') UTILS.waitForAnimation(0, 20) API.RandomSleep2(3000, 2050, 5000) print('waitForAnimation done') UTILS.waitForPlayerAtCoords(lode.loc, 0, 5) print('waitForPlayerAtCoords done') end function LODESTONES.openLodestonesInterface() API.DoAction_Interface(0xffffffff, 0xffffffff, 1, 1465, 18, -1, API.OFF_ACT_GeneralInterface_route) API.RandomSleep2(500, 3050, 12000) end function LODESTONES.AlKharid() GoToLodestone(LODESTONES.LODESTONE.AL_KHARID) end function LODESTONES.Anachronia() GoToLodestone(LODESTONES.LODESTONE.ANACHRONIA) end function LODESTONES.Ardougne() GoToLodestone(LODESTONES.LODESTONE.ARDOUGNE) end function LODESTONES.Ashdale() GoToLodestone(LODESTONES.LODESTONE.ASHDALE) end function LODESTONES.BanditCamp() GoToLodestone(LODESTONES.LODESTONE.BANDIT_CAMP) end function LODESTONES.Burthope() GoToLodestone(LODESTONES.LODESTONE.BURTHOPE) end function LODESTONES.Canifis() GoToLodestone(LODESTONES.LODESTONE.CANIFIS) end function LODESTONES.Catherby() GoToLodestone(LODESTONES.LODESTONE.CATHERBY) end function LODESTONES.DraynorVillage() GoToLodestone(LODESTONES.LODESTONE.DRAYNOR_VILLAGE) end function LODESTONES.Edgeville() GoToLodestone(LODESTONES.LODESTONE.EDGEVILLE) end function LODESTONES.EaglesPeak() GoToLodestone(LODESTONES.LODESTONE.EAGLES_PEAK) end function LODESTONES.Falador() GoToLodestone(LODESTONES.LODESTONE.FALADOR) end function LODESTONES.FortForinthry() GoToLodestone(LODESTONES.LODESTONE.FORT_FORINTHRY) end function LODESTONES.FremennikProvince() GoToLodestone(LODESTONES.LODESTONE.FREMENNIK_PROVINCE) end function LODESTONES.Karamja() GoToLodestone(LODESTONES.LODESTONE.KARAMJA) end function LODESTONES.Lumbridge() GoToLodestone(LODESTONES.LODESTONE.LUMBRIDGE) end function LODESTONES.LunarIsle() GoToLodestone(LODESTONES.LODESTONE.LUNAR_ISLE) end function LODESTONES.Menaphos() GoToLodestone(LODESTONES.LODESTONE.MENAPHOS) end function LODESTONES.Ooglog() GoToLodestone(LODESTONES.LODESTONE.OOGLOG) end function LODESTONES.Prifddinas() GoToLodestone(LODESTONES.LODESTONE.PRIFDDINAS) end function LODESTONES.SeersVillage() GoToLodestone(LODESTONES.LODESTONE.SEERS_VILLAGE) end function LODESTONES.Taverley() GoToLodestone(LODESTONES.LODESTONE.TAVERLEY) end function LODESTONES.Tirannwn() GoToLodestone(LODESTONES.LODESTONE.TIRANNWN) end function LODESTONES.Um() GoToLodestone(LODESTONES.LODESTONE.UM) end function LODESTONES.Varrock() GoToLodestone(LODESTONES.LODESTONE.VARROCK) end function LODESTONES.Wilderness() GoToLodestone(LODESTONES.LODESTONE.WILDERNESS) end function LODESTONES.Yanille() GoToLodestone(LODESTONES.LODESTONE.YANILLE) end return LODESTONES ","keywords":"","version":"Next"}],"options":{"id":"default"}}